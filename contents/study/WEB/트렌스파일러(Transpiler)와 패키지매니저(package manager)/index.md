---
date: '2024-08-03'
title: '[WEB] 트렌스파일러(Transpiler)와 패키지매니저(package manager)'
categories: ['공부', 'WEB']
summary: '트렌스파일러(Transpiler)와 패키지매니저(package manager) 에 대하여 학습하고 정리한 내용입니다.'
thumbnail: './thumbnail.png'
---

# 트렌스 파일러 (Transpiler)

트렌스 파일러란?
Transpiler는 코드를 변환하는 도구를 의미한다. JavaScript의 ES6 문법을 ES5 문법으로 변환하거나, React의 JSX 및 Typescript 코드를 브라우저가 이해할 수 있는 Javascript로 변환하는 도구라고 말할 수 있다. Transpiler 덕에 여러 브라우저 호환성을 유지하면서 다양한 문법을 활용할 수 있는것이다.
대표적인 트렌스 파일러로는 Babel과 SWC가 있다.

눈에 보여지는 도구가 아니었기에 처음 트렌스 파일러를 들었을땐, 어?? 내가 모르던 도구 인데.. 어떤 역할을 해주는거지? 라는 생각이 들었다.

그저 리액트 코드를 자연스럽게 이해하고 해석해줬을거라고 생각하던 것과는 달리 Transpiler라는 도구가 굉장히 열심히 브라우저가 이해할 수 있도록 많은 부분에 도움을 주고 있었고 이에 대해 알게 된 후로부터 다양한 기능에 대해 더 많이 알고 싶다는 생각이 들었다.

### 어디에 위치해 있는거지? 언제 설치했지?

가장 먼저 들게 된 의문은 도대체 트렌스 파일러는 어디서 동작하고 있고 언제 설치가 되어져서 우리의 코드를 잘 해석해주고 있는것일까? 였다.
실제로 나는 모듈 번들러만을 사용하여 프로젝트를 구현하고 시작하였기 때문에, 그저 다 세팅이 되어 있는 프로젝트에서 Transpiler를 설치한 기억이 없었다.

그러던 와중, Vite를 활용해 프로젝트 세팅을 하던 중 언어를 선택하는 시점에서
Javascript / Javascript + SWC / Typescript / Typescript + SWC
라고 4가지의 항목이 있었던 부분이 떠올랐다.
언어 선택시 2번째와 4번째 항목에 있던 swc가 바로 트렌스 파일러 였던 것이고 2,4번째를 선택하지 않은 다른 항목들은 모두 자연스럽게 babel이라는 트렌스 파일러가 함께 세팅 되어졌던 것이었다.

실제로 gpt에게 물어보니, 모듈 번들러로 프로젝트를 구성하는 과정중에 트렌스파일러도 함께 세팅이 되어지고 이 덕분에 우리의 브라우저는 다양한 언어들을 변환하여 잘 이해할 수 있게 된것이라는 사실을 알 수 있었다.

### Babel과 SWC? 차이점은 뭐고 각각의 장단점은 뭘까?

그렇게 어디에 위치해 있는지에 대한 의문점이 해결됨과 동시에 그 후에 이어서 든 의문점은 Babel과 SWC의 차이점은 무엇일까? 였다.

두가지 종류가 있다고 들었는데, 하나 보다 다른 하나가 모든 면에서 더 우세하다! 가 아닌, 상황에 따라 선택해서 개발한다. 로 알고 있었기에 둘에 차이점과 장단점에 대해서 더 알고 싶었다.

이에 대해서 조사해본 결과,

**1. 언어**
Babel: JavaScript로 작성됨.
SWC: Rust로 작성됨.

**2. 성능**
Babel: JavaScript로 작성되었기 때문에, 대규모 프로젝트에서 변환 속도가 느릴 수 있다.
SWC: Rust로 작성된 덕분에 매우 빠른 성능을 자랑한다. Rust의 고성능을 활용하여 더 빠른 컴파일 시간을 제공한다.

**3. 사용자 커뮤니티 및 생태계**
Babel: 오랫동안 사용되어 온 도구로, 널리 알려져 있으며 있다. 다양한 플러그인과 프리셋을 통해 유연한 설정이 가능하다.
SWC: 상대적으로 새로운 도구이지만 빠르게 성장하고 있다. 성능 때문에 점점 더 많은 프로젝트에서 채택되고 있다.

**4. 구성 및 사용 용이성**
Babel: 풍부한 플러그인 시스템과 프리셋 덕분에 설정이 유연하지만, 복잡할 수도 있다.
SWC: 설정이 비교적 단순하지만, Babel만큼의 유연성과 다양한 플러그인은 아직 부족할 수 있다.

**5. 플러그인 시스템**
Babel: 다양한 플러그인과 프리셋을 통해 JavaScript의 최신 기능을 사용할 수 있다.
SWC: 플러그인 시스템이 존재하지만 Babel만큼 다양하고 풍부하진 않다.

**6. 지원 범위**
Babel: 다양한 ECMAScript 버전 및 실험적인 기능을 지원하며, React와 같은 프레임워크에 대한 지원이 잘 되어 있다.
SWC: 최신 JavaScript 기능과 TypeScript 변환에 집중하고 있으며, React를 포함한 몇 가지 주요 프레임워크에 대한 기본적인 지원을 제공한다.

**결론**
Babel은 넓은 범위와 다양한 기능을 제공하지만, 속도 면에서 SWC에 비해 느릴 수 있다.
반면, SWC는 Rust 기반으로 빠른 성능을 제공하지만, Babel만큼의 풍부한 플러그인과 유연성을 제공하지는 않을 수 있다.
프로젝트의 요구 사항과 우선 순위에 따라 적절한 도구를 선택하는 것이 중요하다.

라는 사실을 알 수 있었다.

### 실제 우리가 프로젝트에서 사용한 Babel. SWC로 마이그레이션 할 가치가 있을까?

위와 같은 사실을 알고 난 뒤, Babel은 넓은 범위와 다양한 기능을 제공하지만, 속도면에서는 SWC보다 느리고, 장단점이 명확하다는 것을 깨달았다.

나는 프로젝트를 생성할때 단 한번도 SWC 트렌스파일러를 선택하여 개발해본 경험이 없다.

트렌스파일러의 종류 선택으로 인해 개발에 불편함을 겪는 몇가지 경우가 있는데, 이를 먼저 정리해보자면

**1. 빌드 시간 지연**
원인 =>
복잡한 설정 및 플러그인 사용: Babel과 같은 트랜스파일러는 다양한 플러그인과 프리셋을 지원하지만, 이를 많이 사용하면 빌드 시간이 길어질 수 있다. 특히, 여러 단계의 변환이 필요한 경우 빌드 시간이 크게 늘어난다.
대규모 코드베이스: 코드베이스가 커질수록 트랜스파일러가 처리해야 할 코드의 양도 증가한다. 이는 빌드 시간을 크게 지연시킬 수 있다.

**2. 런타임 성능 저하**
원인 =>
폴리필 사용: 트랜스파일러는 최신 JavaScript 기능을 지원하기 위해 폴리필(polyfill)을 추가할 수 있다. 이는 런타임 시 더 많은 코드가 실행되므로 성능 저하를 유발할 수 있다.
복잡한 코드 변환: 특정 최신 기능을 변환하는 과정에서 생성된 코드가 최적화되지 않으면 런타임 성능이 저하될 수 있다.

**3. 개발 속도 저하**
원인 =>
소스 맵 생성: 디버깅을 용이하게 하기 위해 소스 맵을 생성하는 과정도 빌드 시간을 증가시킨다.
핫 리로딩 지연: 개발 중 핫 리로딩(hot reloading)이 느려지면 생산성이 저하된다.

등등이 있다.

이러한 3가지 항목을 봤을때 Babel을 선택하여 개발했을때 빌드 시간 지연과 런타임 성능저하 그리고 개발속도 저하 적인 부분에서 크게 불편함을 겪는 경우가 없었다. 내가 판단하기로는 우리으 코드 스케일이 그렇게까지 거창한 프로젝트가 아니기에 즉, 토이프로젝트 이기에 큰 불편함을 겪는 경우가 없다고 생각했다.

하지만, 사실 Babel을 사용하는데에 큰 장점은

**1. 플러그인 및 프리셋의 다양성:** Babel은 수많은 플러그인과 프리셋을 제공하여 다양한 요구사항에 맞춰 사용할 수 있다. 이는 SWC보다 더 유연하고 강력한 코드 변환을 가능하게 한다.
**2. 성숙한 생태계:** Babel은 오랜 기간 동안 사용되어 왔기 때문에, 문서화가 잘 되어 있고, 커뮤니티의 지원이 풍부하다. 이는 문제 발생 시 해결책을 찾기 더 쉽다는 것을 의미한다.
**3. 커스텀 변환의 용이성:** Babel의 플러그인 시스템은 매우 유연하여, 필요에 따라 커스텀 플러그인을 작성하여 특정 요구사항을 충족시킬 수 있다.

이렇게 3가지가 있는데, 내가 만든 프로젝트에서는 이 3가지 장점을 적절하게 활용하고 있지 않았고, Babel을 선택한 이유에 대해서 명확하게 이유를 제공할 수 없다라는 생각이 들었다.

### SWC로 마이그레이션에 대한 고민

Babel의 장점을 확실하게 이용하지 못하고 있고, SWC의 장점 또한 무시할 수 없기에 기존 Babel을 활용하여 개발하던 프로젝트를 swc로 마이그레이션을 해볼까 생각하며 이런 과정이 오히려 더 리스크가 많이 들고 위험을 초래할 가능성이 높다면 그만 둬야겠다고 생각했지만,

마이그레이션 하는 과정이 그렇게까지 어렵지 않을 수 있겠다라는 생각이 들었다.
이에 대해서 설명해보면

**1. 필요한 플러그인만 사용:** 불필요한 플러그인을 제거하여 빌드 시간을 단축한다.
**2. 캐싱**: Babel의 캐싱 기능을 활용하여 반복 빌드 시간을 줄인다.
**3. SWC로 마이그레이션:** SWC와 같은 빠른 트랜스파일러로 전환하여 빌드 시간을 단축한다.
**4. 폴리필 최소화:** 필요한 폴리필만 선택적으로 추가하여 런타임 성능 저하를 방지한다.
**텍스트**5. 코드 스플리팅: 코드 스플리팅을 통해 빌드 시간을 분산시킨다.

의 과정을 거치면 됐다.

실제 운영중인 프로젝트를 마이그레이션 하긴 어려우니 프로젝트 레포를 fork 떠서 내 개인 레포에서 트렌스파일러 마이그레이션을 적용해보고 적절하게 동작되면 실제로 적용해봐야겠다는 다짐을 할 수 있었다.

실제로 babel에서 swc로 전환되고 난 후에는 빌드 속도나 렌더링 성능 등등이 얼만큼 올라가며 좋아질 것인지 비교해보고 싶다라는 생각이 들었고 흥미로운 부분에 대해서 공부하고 다뤄 볼 수 있는데 기대 되고 신이 났다.

### 추가적으로 너무나 좋은 자료 !

트렌스 파일러를 공부하면서 Babel의 장점을 너무나 잘 활용하고 이에 대한 설명과 원리를 잘 작성해둔 글을 찾아서 공유한다!
토스 테크 - [ Transpiler, “사용”말고 “활용”하기 ] : https://toss.tech/article/27750

# 패키지매니저 (package manager)

패키지 매니저란?

패키지 매니저(package manager)는 소프트웨어 프로젝트에서 라이브러리, 프레임워크, 모듈 등 외부 패키지들을 관리하는 도구이다.
패키지 매니저는 패키지 설치, 업데이트, 삭제, 의존성 관리 등을 자동화하여 개발자가 쉽게 외부 코드를 사용할 수 있게 해주는데, 이는 개발 효율성을 높이고 프로젝트의 일관성을 유지하는 데 매우 중요한 역할을 한다.

조금 더 간단하게 설명하면,
JavaScript나 TypeScript를 사용하면 이렇게 require나 import 구문을 사용해서 외부 의존성을 참조하곤하는데, 그것을 올바르게 참조할 수 있도록 보장해주는 프로그램이라고 생각하시면 이해하기 편하다!

### 너무나 좋은 패키지 매니저 동작과정에 대한 자료 + 자료 해석 및 설명

토스 테크 - [ 패키지 매니저의 과거, 토스의 선택, 그리고 미래 ] : https://toss.tech/article/lightning-talks-package-manager

일단 설명에 시작하기에 앞서 이 글을 먼저 공유한 이유는 너무나 좋은 글이기 때문이다.. 나도 이 글을 읽고 공부를 시작했는데 이해하는데 도움이 많이 됐고 좋았다.

해당 글을 참고해서 글을 작성해보자면,

결국에 패키지 매니저는 소스코드보다 한단계 상위에 위치한 package.json 파일에 다양한 라이브러리들에 대한 정보를 명시해두고 npm install 이나 yarn add를 통해서 한번에 해당 의존성의 명시된 버전을 설치하면 모호한 버저닝 문제를 해결해주곤 한다는 것이다.

패키지 매니저의 동작과정은

1. Resolution
2. Fetch
3. Link

로 구성 되어져 있다.

Resolution 과정에서는

- 라이브러리 버전 고정
- 라이브러리의 다른 의존성 확인
- 라이브러리의 다른 의존성 버전 고정
  을 진행하고

Fetch 과정에서는

- 결정된 버전의 파일을 다운로드 하는 과정
  을 진행하며

Link 과정에서는

- Resolution/Fetch 된 라이브러리를 소스 코드에서 사용할 수 있는 환경을 제공하는 과정
  을 진행한다고 한다.

이렇게 3가지 단계중에 바로 Link 과정이 가장 복잡하고 Link 과정 때문에 다양한 종류의 패키지 매니저가 나오곤 했다.

### npm vs pnpm vs pnp(yarn classic,yarn berry)

위에서 설명했던 Linker의 개념과 연결지어 적어보자면,

[1] npm Linker
첫 번째로 가장 익숙한 node_modules 기반의 Linker를 살펴보자면, package.json에서 명시하는 모든 의존성을 그냥 node_modules 디렉토리 밑에다가 하나하나씩 쓰는 게 npm Linker의 역할이다.

소스 코드에서 React와 TDS 모바일 라이브러리를 사용한다면, my-service의 node_modules하위에 React랑 TDS 모바일 패키지를 추가해야한다. TDS 모바일 패키지에도 node_modules가 있다면 @radix-ui/dialog를 또 그 밑에 깔아주는 게 npm Linker가 하는 일인것이다.

이러한 npm Linker의 단점은 100개 프로젝트에서 React 18.2.0 버전을 쓴다고 하면 정말로 100번씩 React 18.2.0이 추가된다는 것이었다.

이러한 단점을 극복하기 위해 나온것이 바로, pnpm Linker 이다.

[2] pnpm Linker
pnpm문서에 보면 ‘fast, disk space efficient’한 패키지 매니저라고 써있는데, 퍼포먼스가 향상된(performant) npm 이라고 이해하시면 된다고 한다.

pnpm Linker는 Hard link 방식을 활용해서 기존의 node_modules 디렉토리를 그대로 사용하되, 보다 빠르고 용량을 최적화하는 방식을 사용한다
Hard link를 보통 OS나 시스템 프로그래밍에서 파일 시스템을 관리할 때 쓰는 개념으로 알고 있을건데, 쉽게 말해 alias를 거는 것이라고 생각하면 된다.
npm처럼 단순 복붙하는 게 아니라 alias가 생기면 거기로 바로 접근하는 것이다. 그래서 의존성이 디스크에 하나만 설치가 되고, node_modules를 쓸 때도 파일을 하나하나 쓸 필요가 없어져 속도가 훨씬 빨라진다.

하지만 이 다음에 설명할 pnp 보다는 느릴 수 밖에 없는 이유가 있는데 바로 하나하나 돌면서 alias를 설정해야한다는 점이다.
node_modules 디렉토리는 그대로 유지하기 때문에, require, import 시 파일 읽기가 많이 발생해서 중간중간 멈추기도 한다.

[3] pnp Linker
이 node_modules 디렉토리에서 벗어나고 싶다는 생각으로 래디컬하게 접근한 게 PnP인데,

PnP는 ‘패키지를 import 할 때 중요한 것은 단 두 가지’라는 관점에서 접근한다.
먼저, ‘어떤 파일’에서 import 하는가,
그리고 ‘무엇’을 import 하는가이다.
즉, 앞의 npm과 pnpm처럼 node_modules를 순회하는 게 중요하지 않다고 생각하여, node_modules 디렉토리가 아니라 JavaScript 객체로 똑똑하게 처리하는것이다.

이렇게 PnP는 의존성을 찾는 방법을 JavaScript Map으로 관리한다. 그렇기에 pnpm보다 훨씬 더 속도가 빠르고 디렉토리를 순회할 필요도 없게 되는 것이다.

하지만, 속도에 집중하다보니 Node.js 프로세스가 뜨는 속도가 느리고, node_modules 디렉토리와 호환성이 낮다는 단점을 가지기도 한다.

### 우리가 yarn을 주로 선택해서 사용해온 이유

위와 같은 이유로 더 많은 설명이 적혀있었지만, 토스가 사용하는 패키지 매니저는 pnp Linker를 가지고 있는 yarn이라고 하고 실제로 yarn을 사용하면서 다양한 개발을 진행하고 있다고 한다.

실제로 위와 같은 이유 뿐만 아니라 npm은 30초가 넘게 걸리지만, pnpm은 8초 정도 걸리고, Yarn은 그보다 더 빠르다고 한다.

다양한 이유를 가지고 개발을 진행해오고 있다는 글을 보고 지금껏 아무렇지 않게 yarn이 더욱 더 최신 버전이니 좋을 것이다라는 단순한 생각으로 패키지 매니저를 선택한 내 자신이 너무나 부끄러워졌고 공부한 내용을 기반으로 앞으로 프로젝트 진행에 있어서도 더 명확한 이유를 가지고 패키지 매니저를 선택하여 개발을 진행해야겠다는 생각이 들었다.

### 추가적으로 yarn과 yarn berry에 관하여 (왜 아직 yarn을 더 많이 사용할까?)

yarn 과 yarn berry에 대해서 공부하던 도중 둘에 차이점에 대해서 생각하게 되었다.

yarn berry를 도입하여 프로젝트를 진행해보자 ! 라는 결심으로 도입해본 경험이 있지만 다양한 단점이 있어 다시 yarn으로 마이그레이션 하고 진행했던 기억이 있다.

하지만, 내가 공부한 결과 yarn(classic버전)은 yarn berry 보다는 훨씬 전 버전이고 분명히 단점을 보완하며 업데이트 했을텐데 왜 yarn을 사용하는 사람들이 더 많을까? 라는 의문이 들었던 것이다.

이에 대해서 알아보았는데,

**사람들이 Yarn Classic을 더 많이 사용하는 이유**
**1. 안정성 및 신뢰성:** Yarn Classic은 오랜 시간 동안 사용되면서 많은 문제들이 해결되어 안정적이다.
**2. 호환성: **많은 기존 도구와 npm 패키지들이 Yarn Classic과 잘 호환된다.
**3. 익숙함:** 많은 개발자들이 이미 Yarn Classic을 사용하고 있어, 새로운 도구나 기능을 배우지 않아도 된다.
**4. 기존 프로젝트:** 이미 Yarn Classic을 사용하고 있는 프로젝트에서 Yarn Berry로 전환하는 것은 추가적인 작업과 테스트가 필요하다.

**결론**
Yarn Berry는 더 나은 성능과 디스크 사용 효율성을 제공하지만, 일부 호환성 문제와 새로운 기능의 학습 곡선 때문에 아직 Yarn Classic이 더 널리 사용된다고 한다. 그러나 대규모 프로젝트나 모노레포를 효율적으로 관리해야 하는 경우에는 Yarn Berry가 좋은 선택이 될 수 있다. 각 프로젝트의 요구사항과 상황에 맞게 적절한 패키지 매니저를 선택하는 것이 중요하다고 한다.

위와 같은 이유 때문에 yarn을 사용하는것이고 결국에 내가 예전에 yarn berry를 적절하게 사용하지 못했던 이유는 호환성의 문제가 컸겠구나 라는 생각이 들었다.

### 모노레포 개발에 적절한 pnpm과 yarn berry

위와 같은 다양한 특징에 대해서 공부하면서 알게 된 사실은 pnpm과 yarn berry같은 패키지 매니저들은 바로 모노레포 개발에 적절하다라는 사실이었다.
위 장단점을 공부하고 나니 왜 그런지에 대해서 더 쉽게 이해할 수 있었다.

모노레포란?
여러 개의 프로젝트가 하나의 저장소(repository) 안에 함께 포함된 소프트웨어 개발 접근 방식을 말한다. 이 방식은 여러 프로젝트를 하나의 저장소에서 관리하며, 공통된 코드와 의존성을 공유하고 효율적으로 관리할 수 있도록 한다.

모노레포를 듣고 난 후 Next.js가 모노레포 프로젝트에 적합하다는 이야기를 들어 이에 대해서도 찾아봤는데,
Next.js가 반드시 모노레포(Monorepo) 구조를 가져야 하는 것은 아니고, Next.js는 단일 프로젝트로도 잘 작동하며, 소규모 프로젝트나 단일 애플리케이션을 개발할 때는 굳이 모노레포 구조를 사용할 필요가 없지만, 복잡한 프로젝트나 여러 애플리케이션을 동시에 관리해야 하는 경우에는 모노레포 구조가 유용할 수 있다. 라는 사실을 알 수 있었다.

그래서 추후 모노레포 방식으로 개발을 진행하게 된다면 Next.js와 pnpm혹은 yarn berry를 선택하여 개발할 수 있도록 해야겠다는 다짐을 하게 되었다.
