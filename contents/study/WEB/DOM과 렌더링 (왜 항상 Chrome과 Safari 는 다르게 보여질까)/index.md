---
date: '2024-07-24'
title: '[WEB] DOM / 렌더링 (왜 항상 Chorme과 Safari는 다르게 보여질까?!)'
categories: ['공부', 'WEB']
summary: 'DOM / 렌더링 (왜 항상 Chorme과 Safari는 다르게 보여질까) 에 대하여 학습하고 정리한 내용입니다.'
thumbnail: './thumbnail.png'
---

# DOM

렌더링 관련 개념을 이야기 하기 전에 DOM 관련 개념에 대해서 알 필요가 있다.
DOM이란 HTML데이터들을 파싱해서 만든 노드들의 객체라고 생각하면 된다. (이 과정에 대해서는 렌더링 부분에서 더 설명해주겠다.)

DOM은 웹페이지를 프로그래밍적으로 제어할 수 있게 해주는 객체모델 이다.
DOM를 공부하면서 BOM 개념과 헷갈렸는데 전혀 다른 개념이라고 볼 수 있다.
BOM은 window navigator screen history등 웹 브라우저와 관련된 객체들을 다루는 모델을 의미한다.
하지만 DOM은 HTML 및 XML 문서의 구조화된 표현을 의미하기 때문에 비슷한 용어 일지라도 나타내는 바가 다르다는 것을 알 수 있다.

렌더링을 설명하면서 조금 더 설명해보자면,

# 렌더링

정말 필수적으로 알아야 되는 개념인, 브라우저가 작동 되는 과정에 대해서 설명해볼래요? 라는 질문에 대해서는 렌더링 과정을 설명하면 된다.

렌더링은
**1. 클라이언트에서 불러오고 싶은 파일을 웹 서버에 요청한다.**
이때 웹서버는 HTML API요청을 통해 데이터를 제공해주는 API 서버가 아닌 HTML 코드를 제공하는 서버를 의미한다.
**2. 웹서버에서 응답으로 받은 HTML 데이터를 파싱한다.**
파싱은
바이트 => 문자열 => 토큰 => 노드 => DOM
의 순서로 진행이 되는데
2진수 바이트형태로 응답받은 HTML문서를 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환하고 코드의 최소 단위인 토큰들로 분해한다. 그 후 토큰들을 객체형태로 변환하여 노드들을 생성하고 (문서노드,요소노드,어트리뷰트노드,텍스트노드로 구분된다.)
그후,
**3. HTML 마크업을 바탕으로 DOM 트리를 생성한다.**
노드들을 가지고 트리를 형성하며 (중첩관계를 확인)
이러한 트리를 DOM이라고 한다.
**4. CSS 마크업을 바탕으로 CSSOM 트리를 생성한다.**
HTML과 동일하게 CSS도 파싱하며 CSSOM 트리를 생성하고,
**5. DOM트리와 CSSOM트리를 결합하여 렌더 트리를 형성한다.**
**6. 렌더 트리에서 레이아웃을 실행한다.**
이 레이아웃은 렌더 트리를 기반으로 계산하여 생성이 된다.
**7. 개별 노드를 화면에 페인팅한다.**

이러한 과정으로 이루어 진다.

렌더링 과정중에 자바스크립트 코드가 있다면 잠시 DOM 생성을 일시 중단하고 자바스크립트 코드를 로드한 뒤에 다시 DOM 생성을 이어서 한다고 한다.

렌더링 과정을 공부하며 렌더링 엔진에 대해서도 알아보게 됐는데,

safari chorme firefox 등 브라우저마다 렌더링 엔진이 다르다는 사실을 알 수 있었다.

### 렌더링 엔진에 대하여 (safari와 chorme에서는 왜 항상 다른 오류가 나는 걸까??)

개발을 진행하고 항상 배포페이지에서는 내가 작성한 코드를 확인할 때 화면이 그려지는 부분에 있어서 safari와 chorme이 다르게 표현되는 부분이 있었기에 오류가 나곤 했다.
이런 의문점은 이번 렌더링 엔진을 공부하며 알 수 있었는데,

예전엔 safari와 chorme이 같은 렌더링 엔진을 사용했다고 한다. webkit이라는 !
그래서 webkit 기반으로 렌더링트리를 형성하며 렌더링 했기에 다른 부분이 없었는데 최근엔 chorme이 구글이 webkit을 fork하여 제작한 blink라는 렌더링 엔진을 사용하며 렌더링 엔진이 달라졌다고 한다.

그렇기 때문에
렌더링 엔진(WebKit과 Blink)의 차이,
기본 스타일시트의 차이,
CSS 속성 지원의 차이,
그리고 렌더링 최적화 기술의 차이
등등의 이유로 보여지는 화면이 각 브라우저마다 달랐던 것이었다.

정말 평소에 너무 고생하던 부분에 대해서 팡! 하고 뚫린 해답을 찾았달까...

이러한 차이를 해결하기 위해 CSS 리셋, 크로스 브라우저 테스트, 브라우저 전용 스타일 등을 활용할 수 있다고 하는데,

평소 단순하게 개발을 내가 사용하는 chorme에 맞춰서 진행해 왔었는데 실제 현업에서는 훨씬 더 다양한 환경에 대해 대비하며 제작할 것이기 때문에 그러한 습관화가 지금의 나에게도 진행 되어져 야 한다고 생각했다.

### 브라우저의 렌더링 과정에서 자바스크립트 동작

위에서 자바스크립트 동작 부분을 간단하게 설명해서 이어서 설명해보자면,

1. HTML/CSS 파싱 과정과 마찬가지로 렌더링 엔진은 HTML을 한 줄씩 순차적으로 파싱하며 DOM을 생성해 나가다가 자바스크립트 파일을 로드하는 <script> 태그나 자바스크립트 코드를 콘텐츠로 담은 <script> 태그를 만나면 DOM 생성을 일시 중단한다. (이게 위어서 말했던 내용이다.)

2. 그리고 <script> 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청하여 로드한 자바스크립트 파일이나 <script> 태그 내의 자바스크립트 코드를 파싱하기 위해 ② 자바스크립트 엔진에 제어권을 넘긴다. 이후 자바스크립트 파싱과 실행이 종료되면 ① 렌더링 엔진으로 다시 제어권을 넘겨 HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작하여 DOM 생성을 재개한다. (이 역시 이어지는 내용.)

3. 자바스크립트 파싱과 실행은 ① 브라우저 렌더링 엔진이 아닌 ② 자바스크립트 엔진이 처리한다. ② 자바스크립트 엔진은 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 low-level language로 변환하고 실행하는 역할을 한다.

4. ② 자바스크립트 엔진은 자바스크립트를 해석하여 AST를 생성한다. 그리고 AST를 기반으로 인터프리터가 실행할 수 있는 intermediate code인 바이트코드를 생성하여 실행한다.

5. 리플로우와 리페인트
   만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우 DOM이나 CSSOM이 변경된다.
   이때 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 리플로우(reflow), 리페인트(repaint)라 한다.

토스 accelerator 관련 시험을 볼때 리플로우와 리페인트 개념이 많이 나왔었는데, 해당 부분을 잘 이해하지 못했기에 문제를 잘 풀어나가지 못했다.

이번 기회를 통해 열심히 공부해 볼 수 있어서 좋았다.
