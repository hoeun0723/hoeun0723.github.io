---
date: '2024-07-18'
title: '[Javascript] sExecution context & Closure'
categories: ['공부', 'Javascript']
summary: 'Execution context & Closure 에 대하여 학습하고 정리한 내용입니다.'
thumbnail: './thumbnail.png'
---

# Execution context(실행 컨텍스트)

실행 컨텍스트를 내가 이해한 바로 설명하면, 코드의 실행 순서를 관리하는 개념이다.
사실 그 내부를 조금 더 들어가보면 실행 순서 뿐만 아니라 다양한 정보들을 담고 있다라는 것을 알게 되는데, 그에 대해서 조금 더 설명해 보겠다.

Javascript에는 총 3종류의 코드가 있는데, 글로벌 스코프에서 실행되는 함수 스코프에서 실행하는 함수 코드, 그리고 eval() 로 실행되는 코드가 있다.
이는 각각 자신만의 실행 컨텍스트를 생성한다.

엔진이 스크립트 파일을 실행하기 전에 글로벌 실행 컨텍스트(GEC) 가 생성되고, 함수를 호출할 때마다 함수 실행 컨텍스트(FEC) 가 생성된다. 글로벌의 경우 실행 이전에 생성되고, 함수의 경우 호출할 때 생성이 된다.

실행 컨텍스트는 생성이 되어지면, 스텍에 쌓이게 되는데, 이 스택은 콜 스택(call stack)이라고 부른다.
GEC는 코드를 실행하기 전에 쌓이고 모든 코드를 실행하면 제거되고, FEC는 호출할 때 쌓이고 호출이 끝나면 제거되는 특징을 가지고 있다.

### 구성 요소

실행 컨텍스트는 3가지의 구성요소로 만들어져 있는데,

1. Lexical Environment
2. Variable Environment
3. this 바인딩

이렇게 구성이 되어진다.

Lexical Environment는 변수 및 함수 등의 식별자 및 외부 참조에 관한 정보를 가지고 있는 컴포넌트 이다. 이 컴포넌트는 2개의 구성요소를 갖는다.

1. Environment Record
2. outer 참조

이번 렉시컬 환경을 공부하면서 outer 참조를 알게 되었고, 이 개념이 약간 c언어를 공부할때 포인터 개념과 유사한 성향을 지니고 있다는 사실을 알게 되었다.
렉시컬 환경은 변수나 함수를 나타내는 "식별자" 인것이고 이러한 식별자 정보는 주솟값으로 표현 되어 진다.
그렇기 때문에 outer 참조를 하게 되면 주솟값을 가리키는 역할을 하는 포인터와 동일하게 보여질 수 있는 것이다!

그래서, 코드로 예를 들어보자면

```
var x = 10;

function foo() {
  var y = 20;
  console.log(x);
}
```

이런 변수와 함수가 있을때의 렉시컬 환경은

```
globalEnvironment = {
	environmentRecord = { x: 10 },
	outer: null
}
fooEnvironment = {
	environmentRecord = { y: 20 },
	outer: globalEnvironment
}
```

이렇게 구성이 되어진다.

위 코드에 흐름을 설명해보자면, foo() 에서 x 를 참조할 때는 현대 Environment Record를 찾아보고 없기 때문에 outer 참조를 사용하여 외부의 Lexical Environment에 속해 있는 Environment Record를 찾아보는 방식으로 흘러간다. 가장 먼저 Environment Record를 활용해서 식별자를 확인한 후 outer 참조로 외부의 식별자를 검사하며 찾아나가는 느낌이라고 한다.

Variable Environment는 렉시컬 환경과 동일한 성격을 띠지만 var 로 선언된 변수만 저장한다는 점에서 다르다. 즉, Lexical Environment는 var 로 선언된 변수를 제외하고 나머지(let 으로 선언되었거나 함수 선언문)를 저장한다.

this의 바인딩은 실행 컨텍스트가 생성될 때마다 this 객체에 어떻게 바인딩이 되는지를 나타낸 것이다. (ES6부터 this의 바인딩이 LexicalEnvironment 안에 있는 EnvironmentRecord 안에서 일어난다.)

- GEC의 경우
  - strict mode라면 undefined 로 바인딩된다.
  - 아니라면 글로벌 객체로 바인딩된다. (브라우저에선 window, 노드에선 global)
- FEC의 경우
  - 해당 함수가 어떻게 호출되었는지에 따라 바인딩된다.

### 나만의 의문점과 이해 안 되는 부분에 대한 설명 outer와 this 바인딩

개념을 공부하던 도중 어떠한 포인터역할을 하는 outer와 this 바인딩의 개념이 헷갈렸고 이를 명확히 하기 위해서 공부했다.

**outer**

- outer는 일반적으로 렉시컬 환경과 관련이 있는 개념이다. 함수가 선언된 위치를 기준으로 변수를 참조하곤 하는데, Javascript는 렉시컬 스코핑을 사용하며 함수가 어디서 호출되는지가 아니라 어디서 선언되는지에 따라서 스코프가 결정이 된다. 그렇기에 정적 스코핑(lexical scoping) 이라고 할 수 있고,
  함수 내부에서 외부 함수의 변수를 참조할 때 사용된다.

반면에,

**this 바인딩**

- this 바인딩은 실행 컨텍스트에서 객체를 참조한다. this는 함수가 호출되는 방식에 따라 경정되며, 그 값은 런타임에 동적으로 할당이 된다. 그렇기에 동적 스코핑(dynamic scoping)이라고 할 수 있고,
  객체의 메서드에서 객체 자신을 참조할 때 사용된다.

이렇게 개념을 정리하고 보니 완전히 다른 개념이었고 무언가를 참조한다 만으로 헷갈렸던 거 같아 정리가 개념 이해에 도움이 많이 되었다.
나와 같이 헷갈렸던 사람들을 위하여 정리해 보았다.

### 과정

실행 컨텍스트는 2가지 과정을 거치는데,

1. Creation Phase (생성단계)
2. Execution Phase (실행단계)

위에서 설명했던 3가지의 구성은 모두 생성단계에서 실행 되어지는 것이다.

실행 컨텍스트가 생성이 되어지면서 스택에 쌓이고 없어지는 단계에서 코드의 순차적인 흐름이 흘러가곤 한다.
실행 컨텍스트를 공부하면서 GEC가 종료되고 사라지는 현상으로 인해 코드에서의 불편한 점과 의도치 않은 실행같은 경우가 없을까? 궁금했고, 이는 Closure라는 개념을 공부하면서 조금 더 이해가 충분히 되었다.

# Closure

클로저란, 간단히 말하면 상태(state)를 안전하게 변경하고 유지하기 위해 사용하는 것이다.
다시 말해, 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태변경을 허용하기 위해 사용한다.

GEC가 실행 되고 난 뒤 사라지는 렉시컬 환경들은 사실은 environment record와 outer 참조같은 개념들이 남겨져 있게 된다.
이렇게 남겨져 있지만 제 기능을 하지 못하는 변수와 함수들은 closure의 경우에 실행이 되어지기도 하는데,

closure를 처음 공부할때 어떠한 객체라고 생각했지만, 이러한 상황이 발생하는 모든 코드들의 경우를 클로저 라고 할 수 있는거 같다.

예를 들어서

1. 내부(중첩) 함수가 익명 함수로 되어 외부 함수의 반환값으로 사용될 때
2. 내부(중첩) 함수가 외부 함수의 스코프에서 실행될 때
3. 내부 함수에서 사용되는 변수가 외부 함수의 변수 스코프에 포함되어 있을 때
   closure가 나타나는 경우라고 할 수 있는데,

```
var name = `Global`;
function outer() {
  var name = `closure`;
  return function inner() {
    console.log(name);
  };
}

var callFunc = outer();
callFunc();
```

위 코드에서 callFunc를 클로저라고 한다.
callFunc 호출에 의해 name이라는 값이 console 에 찍히는데, 찍히는 값은 Global이 아니라 closure라는 값이다.
즉, outer 함수의 context 에 속해있는 변수를 참조하는 것이다. 여기서 outer 함수의 지역변수로 존재하는 name변수를 free variable(자유변수) 라고 한다.

이처럼 외부 함수 호출이 종료되더라도 외부 함수의 지역 변수 및 변수 스코프 객체의 체인 관계를 유지할 수 있는 구조를 클로저 라고 한다.

그래서 이 개념을 공부하며 그럼, 중첩함수인 경우에만 클로저가 발생하는건가? 생각했는데, 마냥 그렇지 만은 않고, 이러한 예시도 있었다.

```
//카운터 상태 변경 함수
const increase = function () {
	//카운트 상태 변수
    let num = 0;

    //카운트 상태를 1만큼 증가시킨다.
    return ++num;
}

//이전 상태를 유지하지 못한다.
console.log(increase()); //1
console.log(increase()); //1
console.log(increase()); //1
```

이렇게 1씩 증가하는 함수를 만들고 싶은데, 실행컨텍스트가 종료 되며 작동되어지지 않는 함수는 여전히 1이 증가한 코드만 호출을 시킨다. 그럴때, 즉각 실행 함수를 내부에 작성해주게 되면 클로저가 발생하게 되어 정상적으로 작동이 되어지는데,

```
// 카운트 상태 변경 함수
const increase = (function () {
	// 카운트 상태 변수
	let num = 0;

   // 클로저
    return function(){
    return ++num;
   }
}());

console.log(increase()); //1
console.log(increase()); //2
console.log(increase()); //3
```

이렇게 즉시 실행 함수를 increase 변수에 할당하는 형식으로 작성하게 되면 해당 함수가 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시 실행함수 환경을 기억하는 클로저가 된것이라고 말할 수 있다.

보통 1번째 코드와 같은 경우를 맞이했을때 단순히 반복문을 사용하며 내 코드가 잘못됐구나 생각하고 넘어갔었는데, 이렇게 실행 컨텍스트 개념을 공부하고 closure를 공부하니까, 내가 원하는 기능을 단순히 클로저를 만듦으로써 해결 할 수 있었구나를 알 수 있었던 거 같다.
