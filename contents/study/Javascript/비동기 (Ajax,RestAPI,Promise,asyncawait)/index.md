---
date: '2024-07-22'
title: '[Javascript] 비동기 (Ajax,RestAPI,Promise,async/await)'
categories: ['공부', 'Javascript']
summary: '비동기 (Ajax,RestAPI,Promise,async/await) 에 대하여 학습하고 정리한 내용입니다.'
thumbnail: './thumbnail.png'
---

# 비동기

현재 실행 중인 태스크가 종료될 때까지 다음에 실행될 태스크가 대기하는 방식 을 동기 처리 방식이라고 하며
현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식 을 비동기 처리라고 한다.
대표적으로 타이머 함수인 ① setTimeout/ setInterval ② HTTP 요청 ③ 이벤트 핸들러 는 비동기 처리 방식으로 동작한다.

자바스크립트는 싱글 스레드 방식으로 동작되는데, 한번에 하나의 테스크만 실행할 수 있기에 생성된 실행컨텍스트가 실행 컨텍스트 스택에 푸시 되고 팝 되면서 다양한 실행컨텍스트들이 대기하거나 실행되어진다.

그래서 동기적인 코드의 경우, 실행컨텍스트가 스텍에 쌓인 순서대로 LIFO 하게 실행이 되어지는데, 이는 현재 실행 중인 테스크가 종료될 때까지 다음에 실행될 테스크가 대기하는 방식으로 진행된다.

하지만, 비동기 코드에서는
자신의 전 함수가 블로킹하는 일을 없애고 곧바로 실행 될 수 있도록 해놓는다. 예를 들어 setTimeout 함수도 대표적인 비동기적 동작을 하는 함수인데, 이 일정 시간이 끝나게 되면 실행되도록 코드를 작성하면 그런 실행이 아닌 함수들은 순차적인게 아닌 바로 실행이 되어지는 non-blocking이 나타나게 된다.

이와 같이 비동기 처리 방식은 blocking이 발생하지 않는다는 장점이 있지만, 동시에 테스크의 실행 순서가 보장되지 않는다는 단점이 있다.

### 비동기 처리 과정

비동기적인 코드가 실행 되는 과정에 대해서 설명을 하기 위해선 저번 포스트에서 다뤘던 실행 컨텍스트 개념을 이해하고 올 필요가 있다.

변수나 함수가 생성이 되면 실행컨텍스트역시 생성이 되어지고 이는 콜스택이라고 부르는 곳에 저장이 된다. 동기적인 코드라면 순차적으로 LIFO 하며 POP 되는 순서대로 실행이 되어지지만, 비동기적인 코드의 경우 테스크 큐에 저장이 되었다가 이벤트 루프에 의해서 콜스택에 다시 이동되며 실행순서가 됐을때 pop 되며 작동이 되어지곤 한다.
싱글 스레드 방식이기에 콜스택에 쌓인 후 pop 되어질때 하나씩만 실행이 되어진다는 것을 알 수 있다.

# AJAX

처음 ajax를 공부할때 비동기적인 코드와 다른점이 뭐지?? 라는 의문점이 들며 개념적인 부분에 있어서 헷갈렸었다. 하지만, 비동기 개념과 ajax를 같은 레벨이라고 생각하지 말고, 비동기적인 코드 중에 "데이터"를 비동기적으로 주고 받는 개념은 ajax라고 생각하니 이해가 어려운 부분이 없어졌던 거 같다.

AJAX란, Javascript And XML의 약자로, 비동기적으로 JS를 사용해서 데이터를 받아와 동적으로 DOM을 갱신 및 조작하는 웹 개발 기법을 의미한다. 여기서 XML이 있는 이유는 예전엔 데이터 포맷으로 XML을 많이 사용했기 때문이다.

AJAX는 사용자가 AJAX가 적용된 UI와 상호작용하면, 서버에 AJAX 요청을 보내게 된다.
서버는 DB에서 데이터를 가져와서 JS 파일에 정의되어 있는 대로 HTML/CSS와 데이터를 융합하여 만든 DOM 객체를 UI에 업데이트 시킨다. 비동기로 이루어지며, 기존의 페이지를 전부 로딩하는 방식이 아닌 일부만 업데이트 하는 방식이다.

AJAX를 공부하고 난뒤 XMLHttpRequest 와 Fetch api 가 ajax라고 말할 수 있다는 사실을 깨달았고, 비동기적으로 데이터를 주고받는 방식을 ajax 요청이라고 하는 구나를 알 수 있었다.

실제로 XMLHttpRequest를 활용해서 api요청을 해본 경험이 적은거 같은데 (뒤에서 말할 async/await를 집중적으로 사용함) 이러한 다양한 ajax 요청 방식을 꼭 한번씩은 사용해 봐야겠다라는 생각이 들었다.

# Rest API

rest api 같은 경우는 웹개발을 하며 자주 다뤘던 개념이기에 사용 방법이나 개념적인 부분에 있어서 그리고 메소드 종류에 있어서 어려운 부분은 없었지만, 다양한 ajax 요청에 따른 rest api 적용이 아무런 참고자료 없이 자유자제로 가능할까? 라는 물음에 확실하게 네 ! 라고 답변할 수 없다라는 사실을 깨닫고, 앞으로 네! 라고 확실하게 말할 수 있게 되도록 노력해봐야겠다고 생각했다.

# Promise

Promise 같은 경우는 주로 ts를 사용하면서 객체 형태의 데이터를 비동기적으로 요청받을때 사용하던 코드였다.
Promise 는 비동기 처리를 위한 패턴중 하나로 콜백 함수를 사용하곤 하는데, 콜백함수를 사용함으로써 비동기적인 과정을 수행한다는 것을 알 수 있다.

또한, Promise 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타낸다고 한다.
Promise 생성자 함수를 new 연산자와 함께 호출하면 프로미스(Promise 객체)를 생성한다.
ES6에서 도입된 Promise는 호스트 객체가 아닌 ECMAScript 사양에 정의된 표준 빌트인 객체다.
Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달받는데 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받는다.

실제로 프로젝트에서 사용했던 Promise는 대부분 Promise 객체들이었고, 이는 비동기적인 객체를 받아올때 필수적으로 써줘야 했기에 사용했었다. Promise를 단순히 객체 형태로만 알고 있었지만, 그 외에도 Promise와 관련된 다양한 함수가 있다는 사실을 알고 흥미롭게 느껴지며 사용해보고 싶다고 생각했다.

Promise.resolve/ Promise.reject
Promise.all
Promise.race
Promise.allSettled

이와 같은 종류들이 있었는데, 각각 Promise 객체가 제공하는 정적 메소드 들이다.

.resolve와 .reject는 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용하고,
.all은 여러 개의 비동기 처리를 모두 병령처리할 때 사용한다.
.all은 Promise의 여러 상태에 따라서 동작흐름을 이해할 수 있는데 모두 fulfilled가 된 상태에만 작동이 되어진다고 한다.
.race는 .all 메서드와 동일하게 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받고,
.allSettled는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다.

.race 같은 경우도 Promise의 상태에 따라 흐름이 결정이 되어지곤 하는데 다양한 비동기적인 처리를 하는 코드들을 위와 같은 메소드들을 활용하여 실행 순서를 원하는 흐름대로 만들 수 있다는 사실에 놀라웠고, 꼭 사용해 봐야겠다고 느꼈다.
하지만, 그와 동시에 각 메소드들의 특징을 잘 인지하고 사용하여 내가 원하는 흐름방식이 아니게 흘러가 오류가 나는 경우에 대해서 조심할 필요가 있다고 생각했다.

# 제너레이터

ES6에서 도입된 제너레이터(generator)는 코드 블록의 실행을 일시 중지 (블로킹) 했다가 필요한 시점에 재개할 수 있는 특수한 함수다.

제너레이터는

1. 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.
2. 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.
3. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.
   와 같은 특징을 가지고 있다.

이러한 제너레이터를 보면서 테스크의 실행 순서가 보장되지 않는다는 단점을 가지고 있는 비동기적인 코드들의 특징을 극복 할 수 있는 하나의 방식이 되지 않을까 라는 생각을 했다.

일시적으로 블로킹을 하는 기능을 쥐어주면 비동기요청이 다양하게 발생할때 원하는 순서대로의 흐름이 작동 가능 할 것이라는 생각이 들었다. 실제로 코드를 작성하면서 비동기적인 코드들의 많은 요청으로 흐름이 꼬인적이 있는데,(이는 내가 분명히 비동기적인 코드에 대한 완벽한 이해를 하지 않고 진행해서 이다.) 제너레이터 등등 그리고 비동기적인 개념을 다시 한번 더 공부하고 적용하면서 해당 문제를 해결해 나가보고 싶다는 생각을 했다.

# Async / Await

내가 가장 많이 사용해 왔고 익숙한 비동기 처리 관련 문법인데,
async / await는 ES8에서 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있도록 도입되었다.

async/await는 프로미스를 기반으로 동작하기 때문에 프로미스의 then/catch/finally 등의 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스를 사용할 수 있다.

다시 말해, 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있다는 것이다.

이러한 async/await 의 특징은 프로미스에서 단점으로 여겨졌던 부분에 대해서 장점을 가지곤 하는데, 내가 직접 느껴본 장점은 가독성이 확연히 높아진다는 점이었던 거 같다. 실제로 나도 async/await를 많이 활용했지만, promise메소드를 사용하는등 다른 방식의 ajax 요청 시 다른 방식을 사용할 필요가 분명히 있을것이라고 느끼면서 무조건 적으로 async/await만 고집하는 일은 멈춰야겠다고 생각했다.

# 비동기 관련 개념에 대하여

비동기 관련 개념을 공부하며 너무나 부족했고 평소 흥미로웠던 내용에 대하여 학습할 수 있게 된거 같아 너무 뿌듯했다. 하지만 아직 아주 작은 부분에 대한 공부를 했다고 느꼈고, 이와 이어지는 개념들을 마인드 맵 해가며 더 뻗어나가보고 싶다는 생각을 했다.

그래도, 비동기 개념들과 흐름들에 대한 이해를 할 수 있었던 스터디만으로 만족한다 !
