---
date: '2024-07-17'
title: '[Javascript] scope 그리고 this'
categories: ['공부', 'Javascript']
summary: 'scope 그리고 this 에 대하여 학습하고 정리한 내용입니다.'
thumbnail: './thumbnail.png'
---

# Scope (스코프)

### scope란?

**자바스크립트 엔진이 참조의 대상이 되는 식별자(Identifier)를 검색할 때 사용하는 규칙의 집합 **
이다.

scope의 종류는
전역 scope와 지역 scope로 나눌 수 있는데, 지역 scope에는 함수 scope와 변수 scope가 존재한다.

전역이란 코드의 가장 바깥 영역을 의미하며, 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 된다. 이 전역 변수는 어디서든 참조할 수 있다는 특징을 가지고 있다.
지역이란 함수 몸체 내부를 말한다. 지역은 지역 스코프를 만드는데, 지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수가 된다. 지역 변수는 자신의 스코프와 하위 지역 스코프에서 유효하다.

### 렉시컬(Lexical) 스코프

프로그래머가 코드를 짤 때, **변수 및 함수/블록 스코프를 어디에 작성하였는가에 따라 정해지는 스코프** 를 렉시컬 스코프라고 한다.
"렉시컬(Lexical)" 이라는 명칭이 붙은 이유는 자바스크립트 컴파일러가 소스코드를 토큰(Token)으로 쪼개서 의미를 부여하는 렉싱(Lexing) 단계에 해당 스코프가 확정되기 때문이다.
변수 혹은 함수/블록이 어디에 써있는가를 보고 그 스코프를 판단하면 된다.

렉싱 단계에서 스코프가 확정이 되어지는데, 그럼 어떤 기준으로 스코프가 확정 되는지 즉, 그 과정에 대해서 알고 싶을 수 있다. 함수/블록의 위치를 따라서 스코프가 생성되어지는 과정은 바로, 스코프 체인에 대해서 알아보면 된다.

### 스코프 체인

현재 스코프에서 식별자를 검색할 때 상위 스코프를 연쇄적으로 찾아나가는 방식 을 말한다.
실행 컨텍스트에서 컨텍스트가 생성될 때마다 LexicalEnvironment가 만들어지고
그 안에 outer 참조 값이 있다는 것을 알 것이다.
바로 이 outer 참조 값이 상위 스코프의 LexicalEnvironment를 가리키기 때문에 이를 통해 체인처럼 연결되는 것이다.

즉, 다음과 같은 과정으로 스코프 체인을 검색한다.

1. 현재 실행 컨텍스트의 LexicalEnvironment의 EnvironmentRecord에서 식별자를 검색한다.
2. 없으면 outer 참조 값으로 스코프 체인을 타고 올라가
3. 상위 스코프의 EnvironmentRecord에서 식별자를 검색한다.
4. 이를 outer 참조 값이 null 일 때까지 계속하고 찾지 못한다면 에러를 발생시킨다.

이러한 과정으로 스코프 체인이 발생하며 연쇄적으로 찾아나가곤 한다.

# this

이번에 this 개념을 공부하면서 내가 this를 활용한 경우가 정말 없다는 사실을 깨달았다.
생성자 함수를 활용하여 코드를 작성해본 경험이 없었고, 객체를 생성할때 this를 활용할 생각이 없었던 거 같다.

### this란?

자바스크립트에서 모든 함수는 실행될 때마다 함수 내부에 this라는 객체가 추가된다. arguments라는 유사 배열 객체와 함께 함수 내부로 암묵적으로 전달되는 것이다. 그렇기 때문에 자바스크립트에서의 this는 함수가 호출된 상황에 따라 그 모습을 달리한다.

**1. 객체의 메서드를 호출할 때**

```
var newObject = {
  name: "foo",
  sayName: function() {
    console.log(this);
  }
};
newObject.sayName();
// console> Object {name: "foo", sayName: sayName()}
```

객체의 프로퍼티가 함수일 경우 메서드라고 부른다. this는 함수를 실행할 때 함수를 소유하고 있는 객체를 참조한다. 즉 해당 메서드를 호출한 객체로 바인딩된다. A.B일 때 B함수 내부에서의 this는 A를 가리키는 것이다.

**2. 함수를 호출할 때**

```
var value = 100;
var newObject = {
  value: 1,
  func1: function() {
    console.log(`func1's this.value: ${this.value}`);

    var func2 = function() {
      console.log(`func2's this.value ${this.value}`);
    };
    func2();
  }
};

newObject.func1();
// console> func1's this.value: 1
// console> func2's this.value: 100
```

특정 객체의 메서드가 아니라 함수를 호출하면, 해당 함수 내부 코드에서 사용된 this 는 전역객체에 바인딩 된다. A.B일 때 A가 전역 객체가 되므로 B함수 내부에서의 this는 당연히 전역 객체에 바인딩 되는 것이다.

**3. 생성자 함수를 통해 객체를 생성할 때**

```
var Person = function(name) {
  console.log(this);
  this.name = name;
};

var foo = new Person("foo"); // Person
console.log(foo.name); // foo
```

그냥 함수를 호출하는 것이 아니라 new키워드를 통해 생성자 함수를 호출할 때는 또 this가 다르게 바인딩 된다. new 키워드를 통해서 호출된 함수 내부에서의 this는 객체 자신이 된다. 생성자 함수를 호출할 때의 this 바인딩은 생성자 함수가 동작하는 방식을 통해 이해할 수 있다.

new 연산자를 통해 함수를 생성자로 호출하게 되면, 일단 빈 객체가 생성되고 this 가 바인딩 된다. 이 객체는 함수를 통해 생성된 객체이며, 자신의 부모인 프로토타입 객체와 연결되어 있다. 그리고 return 문이 명시되어 있지 않은 경우에는 this로 바인딩 된 새로 생성한 객체가 리턴된다.

**4. apply, call, bind 를 통한 호출**
this를 자바스크립트 코드로 주입 또는 설정할 수 있는 방법이다.

### this 활용에 대해서

사실, this 활용에 대해서 고민해 보았다. 과연 this 사용이 좋을까?
this가 꼭 필요한 경우가 있다. 생성자 함수를 통해 해당하는 객체를 지정해야할 경우 필요하다. 하지만, 그 외에 객체를 바인딩하는 경우, 동적 바인딩이 되기 때문에
함수의 형태에 따라 바인딩하는 객체의 형태가 달라진다. 그렇기 때문에 내가 의도한 바인딩이 되어지지 않을 수 있고, 가독성이 높은 코드라고 할 수 없을 거 같다고 느꼈다.
