---
date: '2024-07-17'
title: '[Javascript] 프로토타입'
categories: ['공부', 'Javascript']
summary: '프로토타입에 대하여 학습하고 정리한 내용입니다.'
thumbnail: './thumbnail.png'
---

# [Prototype] 이란?

객체 지향형 프로그래밍이란 ?
객제 지향형 프로그래밍은 프로그램을 단순히 함수나 명령어들의 목록으로 보는 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러 개의 독립적인 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 의미한다.

**그럼, Javascript도 객체 지향형 프로그래밍 언어라고 할 수 있냐 !**
YES. Javascript도 객체 지향형 프로그래밍 언어라고 할 수 있고 명령형, 함수형 프로그래밍을 지원하는 멀티 패러타임 프로그래밍 언어라고 할 수 있다.
하지만, Javascript는 Java와 c++과 같은 클래스 기반 객체지향 프로그래밍 언어가 아니고,
**프로토타입 기반의 객체지향 프로그래밍 언어** 이다.

**그럼, 프로토타입이 뭔가요 ??**
프로토타입은 상속을 구현하기 위해 사용되어집니다. 어려운 말이라고 생각이 들 수 있는데,
Javascript의 모든 객체는 자신의 "원형(prototype)" 이 되는 객체를 가지며 이를 프로토타입이라고 한다.
이는 보이지 않는 속성이고, [[Prototype]]이 자신의 프로토타입 객체를 참조한다. (이를 **proto**라는 속성으로 참조할 수 있기도 합니다.)

한가지 의문점이 생긴것은, Javascript에서도 class 개념이 존재하는 것으로 알려져 있는데, 왜 프로토타입 기반의 객체지향 프로그래밍 언어로 불리는 지 궁금했다.

해당 부분을 알아본 결과, Javascript는 상속을 위해 클래스를 정의해야하는 클래스 기반 언어와는 다르게 동적으로 프로퍼티와 메서드를 추가하거나 수정하며 더 간단하고 빠르게 구현하는 것에 집중한 언어인데, 동적인 특성들과 더 간단하고 쉬운 객체 생성 등 다양한 이유들로 인해 프로토타입에 기반한 객체지향 모델을 채택하게 되었다고 한다.
하지만, 내가 현재 사용하고 있는 ES6 문법 부터는 class 개념이 도입 되었는데, 이는 단지 개발자들이 익숙하고 class 기반 문법을 사용할 수 있게 하여 코드의 가독성과 유지보수성을 높이는데 도움을 주기 위함이지 근본적인 프로토타입 기반 구조는 변하지 않았다고 한다.

### 프로토타입에서 항상 헷갈리는 부분 => .prototype과 [[Prototype]]

프로토 타입을 공부하다보면 헷갈리는 개념이 있는데, 바로 .prototype과 [[Prototype]]이다.
명명하는 방식이 비슷해서 헷갈리는것 같다고 생각한다.
그래서 각각을 설명해보자면,

1. [[Prototype]] 은 자신의 프로토타입 객체를 참조하는 속성이다. (**proto**)로도 가능하다.
2. .prototype 은 new 연산자로 자신을 생성자 함수로 사용한 경우, 그걸로 만들어진 새로운! 객체의 [[Prototype]] 이 참조하는 값이다.

.prototype의 설명을 위하여 코드를 작성해보면,

```
function foo() {}
var a = new foo();
```

foo 를 생성자로 호출하여 새로운 객체 a를 생성한다. 그렇게 되면,

1. a의 프로토타입 객체는 생성자 함수로 사용한 foo의 속성인 foo.prototype이 된다.
2. foo.prototype은 constructor 속성을 가지며 이는 실제 객체 foo를 가리킨다.
3. foo.prototype 또한 객체이므로 [[Prototype]]을 가지고 이는 모든 객체의 원형이 되는 객체인 Object.prototype을 가리킨다.

### 프로토타입 체인

위와 같이 .prototype 과 [[Prototype]]에 대해서 공부하다보면, 객체가 생성 되는 과정에 대해서 흐름을 알게 된다. 저번 scope 개념을 공부하며 scope가 정해지는 과정에 대해서 scope 체인을 통해 알아보곤 했는데,
이번에도 프로토타입 체인에 대해서 알아보도록 하겠다.

=>
어떤 객체의 프로퍼티를 참조하거나 값을 할당할 때 해당 객체에 프로퍼티가 없을 경우, 그 객체의 프로토타입 객체를 연쇄적으로 보면서 프로퍼티를 찾는 방식을 프로토타입 체인이라고 한다.

- 프로퍼티를 참조할때
  - 찾고자 하는 프로퍼티가 객체에 존재하면 사용하고,
    - 그렇지 않다면 [[Prototype]] 링크를 타고 끝까지 올라가면서 해당 프로퍼티를 찾는다.
    - 찾으면 그 값을 사용하고 없으면 undefined를 반환한다.

의 과정을 가진다. 프로토타입을 선언했을때 undefined가 나오는 경우가 있었는데 프로토타입 체인에 대해서 알게 되니 해당 undefined가 어떤 과정으로 나오게 되었는지 알 수 있었다.

- 프로퍼티에 값을 할당할 때
  - 찾고자 하는 프로퍼티가 객체에 존재하면 값을 바꾸고,
    - 프로퍼티가 없고 [[Prototype]] 링크를 타고 올라가서 해당 프로퍼티를 찾았을 경우
      - 그 프로퍼티가 writable: true 라면 새로운 직속 프로퍼티를 할당해서 상위 프로퍼티가 아닌 동일한 이름의 프로퍼티가 있을때는 하위 프로퍼티가 되어버리는 현상이 발생한다.
        - 그 프로퍼티가 writable: false 라면 비엄격 모드에선 무시되고 엄격 모드에선 에러가 발생한다.
        - 해당 프로퍼티가 세터(setter) 일 경우, 이 세터가 호출되고 가려짐이 발생하지 않는다.

어떠한 값을 할당하는 경우에는 상위프로퍼티가 가려지는 현상이 발생하곤 하는데, 그럴때 writable을 false로 설정해두고 에러가 발생하도록 하여 원하는 결과 값이 잘 작동할 수 있도록 하는 과정이 필요하다는 것을 알 수 있었다.
하지만 writable true 인 경우도 필요하기에 프로토타입 체인을 잘 이해하며 코드를 작성하는것이 중요하다고 생각했다.

**proto**에 대하여
공부를 하다보니 **proto**사용에 단점이 존재하여, 이에 대한 대안책이 나왔고, **proto**사용을 줄이고 대안책을 활용하라는 글들이 많이 적혀 있어 이에 대해서도 공부해보았다.

먼저, **proto**는 객체의 프로토타입을 나타내는 내부 프로퍼티인데, 이는 ECMAScript 표준에는 포함되어 있지만, 주로 비표준적인 방식으로 여겨지곤 한다.
**proto**를 자주 사용하면 프로토타입 체인을 따라가는 과정에서 성능이 저하될 수 있고, 잘못된 프로토타입 설정으로 인해 디버깅이 어려워질 수 있다.
다양한 이유로 인해 대안책들이 나왔는데, 그중 하나가 바로
Object.create 이다.

Object.create()은 프로토타입 객체를 받아 연결시켜서 새 객체를 만드는 함수로, 프로토타입 객체를 바꾸기 때문에 원래의 constructor를 잃어버리는 특징을 가지고 있다.
**proto**를 대체 하여 사용하는 다양한 함수들이 장점을 가지고 있지만, 명확한 사용을 하지 않으면 내가 원하는 결과값을 얻을 수 없는 경우가 생기기 때문에 정확한 파악 후 사용 해야한다.

예시 코드를 적어보자면,

```
function foo1() {}
function foo2() {}

foo2.prototype = Object.create(foo1.prototype);
console.log(foo2.prototype.constructor); // foo1
```

이 코드에서는 프로토타입 객체가 foo1.prototype으로 바뀌었고 이에 따라 constructor 값을 잃어버리게 된다. 따라서 프로토타입 체인을 통해서 foo1.prototype의 constructor인 foo1을 출력하게 된다.

그 외에도 프로토 타입과 관련된 함수 및 연산자가 존재하는데, 이러한 코드들을 적극적으로 활용해 봐야겠다고 다짐했다.

실제 내가 진행중인 프로젝트에서는 객체관련 부분이 서버를 통해 받아오는 경우였기에 여기에 프로토타입 개념을 적용한 코드를 작성해보며 사용하면 더 효율적인 코드가 되지 않을까 대화를 나눴다.
