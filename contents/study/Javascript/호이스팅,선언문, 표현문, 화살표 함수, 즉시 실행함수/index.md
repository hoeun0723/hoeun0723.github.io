---
date: '2024-07-16'
title: '[Javascript] 호이스팅 / 선언문 vs 표현문 vs 화살표 함수 / 즉시 실행함수(IIFE)'
categories: ['공부', 'Javascript']
summary: '호이스팅 & 선언문 vs 표현문 vs 화살표함수 & 즉시 실행함수 에 대하여 학습하고 정리한 내용입니다.'
thumbnail: './thumbnail.png'
---

# Hoisting (호이스팅)

호이스팅이란? 간단하게 한줄로 정리해 보면,
**변수 및 함수 선언문이 스코프 내의 최상단으로 끌어올려지는 현상**
이라고 할 수 있다.

예를 들어보면,

```
console.log(x);
var x = 100;
```

이렇게 코드를 작성하였을때, x 라는 변수가 호이스팅 되면서 코드적인 오류가 나는 것이 아닌 콘솔창에 undefined 라는 결과가 찍히게 된다.

Javascript에서 선언이 되어지는 모든 변수와 함수는 호이스팅 되어진다.
hoist 라는 단어에 조금 더 집중해서 설명해보면, **변수의 정의가 그 범위에 따라 *선언*과 *할당*으로 분리되는 것**을 의미한다는 것을 알 수 있는데,
변수가 함수 내에서 선언되었을 경우, 선언이 함수의 최상위로,
함수 바깥에서 정의되었을 경우, 전역 컨텍스트의 최상위로 호이스트 되어진다.
하지만 변수가 할당이 되어진다면, 할당 구문은 런타임 과정에서 이루어지기 때문에 호이스트가 발생하지 않는다는 것을 알 수 있다.

이러한 현상은 Javascript 해석기 때문인데, 코드의 라인 순서와 관계 없이 함수 선언식(함수 표현식 X)과 변수를 위한 메모리 공간을 먼저 확보하는 기능을 하기 때문이다.

이렇게 호이스팅 되어지는 것이 과연 좋다고 할 수 있을까?

호이스팅이 되어지면, 변수 선언과 함수 선언을 순서에 구애받지 않고 자유롭게 할 수 있다는 장점이 존재 한다.
하지만, 호이스팅이 되어지면 결과 예측이 더욱 더 어려워지게 된다고 생각한다. 순차적으로 작동되지 않는 코드는 코드 상에서 리펙토링이나 오류 파악에 어려움을 주고, 실제로 비동기적인 처리에서 어려운 부분이 바로 순차적으로 발생하지 않는 코드들로 인해 원인 파악이 어려울 수 있다는 것이다. 위와 같은 이유로 나는 호이스팅이 발생하는 현상이 물론 좋은 점도 있겠지만, 발생하지 않도록 하는 것이 좋겠다 라는 결론을 내렸고,

ES6버전의 Javascript에서는 let/const가 호이스팅이 발생하지 않도록 하는 특징을 가지고
호이스팅을 예방하기 위해서 var의 사용을 줄이고 let/ const를 사용하는 것을 지향하고 있다.

변수 호이스팅을 이해하고 난 뒤, 함수 호이스팅에 대해서도 알아보면, 아래쪽에 선언된 함수가 순서 상관없이 호이스팅 되는 모습을 확인할 수 있다. 하지만, 어떠한 변수에 할당 되어지는 함수는 호이스팅이 발생하지 않는다.

이렇게 함수 호이스팅을 공부하다보면 한가지 더 알아보고 싶은 점이 생긴다.

# 함수 선언문 vs 표현문

바로 함수의 선언문과 표현문이다.
종종 개발을 시작하는 단계에 앞서서 컨벤션을 정하기 위해서 선언문과 표현문의 형태중 어느 형태로 함수를 작성해 나갈 것인지 이야기 하곤 한다.

실제로 나도 개발때 정말 많이 논의 해본 부분이기도 하고, 코드 리뷰를 달면서도 함께 토론한 경험도 있었다.

선언문은

```
function foo() {
console.log("hello");
}
```

이렇게 함수만 선언되어져 있는 형태를 의미하고,
표현문은

```
var foo = function() {
console.log("hello");
}
```

이런식으로 변수에 할당 되어지는 형태를 취하고 있다.

위에서 한 호이스팅 이야기와 연관지어 이야기 해보자면,
선언문은 함수를 "선언" 한 상태이기 때문에, 호이스팅이 발생한다.

하지만 표현문은 변수에 함수를 "할당" 한 상태이기 때문에, 호이스팅이 발생하지 않는다.

위에서 언급하였듯이 호이스팅은 각각의 장단점을 가지고 있는데, 이에 따라서 선언문과 표현문을 적절하게 선택하여 사용하는것이 좋을 거 같다고 생각한다.

나는 호이스팅이 발생하지 않는 경우가 오류 파악에 더 좋을 것이라고 판단하였지만, 왜인지 JS로 개발하는 프로젝트들은 모두 다 선언문을 자연스럽게 사용하고 있었다. 그에 대한 이유를 생각해보았는데,

보통 vite나 cra로 react를 활용해 개발 환경을 구축하게 되면(언어가 Javascript인 경우), 생성되는 함수의 형태가 선언문의 형태였다. 그래서 인지 자연스럽게 선언문의 형태로 작성하게 됐던 거 같고, 추가적으로 보통 React코드 작성에 있어서는 한 페이지에는 하나의 함수를 기준으로 코드를 작성해 왔었기 때문에 호이스팅으로 인해 리펙토링이나 오류 파악에 어려움이 없었던거 같다고 판단했다. 오히려 위치에 구애받지 않고, 오류가 나지 않는 호이스팅의 기능을 더 유용하게 사용한 것이 아닐까 라는 결론을 내렸다.

하지만, 이번에 호이스팅을 공부한 후, 함수 형태에 대해서 고민 하던 중 다양한 함수나 변수에서의 호이스팅을 방지하는 경우 변수 할당 방식이 있다는 사실을 깨달았고, es6 문법을 사용하는 나로써는 앞으로 개발을 할때 표현문을 활용하여 개발하면 좋겠다는 생각을 했다.

### 화살표 함수

추가적으로 화살표 함수에 대해서도 말하고 싶은데, 화살표 함수 역시 변수에 할당한 형태이기 때문에, 호이스팅이 발생하지 않는다. 표현문과 화살표 함수가 완전 동일하다고는 할 수 없지만, 좋은거 남기고 불편했던거 고치고 없애면서 업그레이드 시킨 버전이라고 생각한다.

화살표 함수는 TS로 개발할때 유용하게 쓰였는데, 호이스팅이 발생하지 않으며, type이 함께 적힌 코드에서의 가독성을 높이고 (코드가 굉장히 깔끔해짐) 등등의 이유가 있어서 즐겨 사용했던 거 같다.

추후 JS 를 활용한 개발을 진행할때도, 화살표 함수를 활용해야겠다라는 생각을 했고, 단순히 생각 없이 선언문 사용하자! 라는 행동을 이제는 버리기로 결심했다.
하지만 타당한 이유가 있다면 사용하는 것이 맞다!!!

# 추가적으로 IIFE에 대하여

위 내용을 공부하면서 함수 관련 부분을 대화 나누다보니 즉시 실행 함수 표현식(Immediately-Invoked Function Expression)에 대해서도 공부하게 됐다.

즉시 실행 함수 표현식은 두가지 조건이 있는데,

1. 즉시 실행하여야 한다.
2. 함수 표현식이어야 한다. ( = 함수 선언문이 아니어야 한다. )
   즉, 함수 표현식을 즉시 실행하는 것을 말하며 해당 함수는 익명함수와 기명함수 모두 가능 하다.

예시 코드를 적어보자면,

```
(function(){
  console.log('IIFE');
})();
```

이런 느낌인 것이다 !

이런 IIFE 코드를 직접 활용하여 써본 경험이 언제 있지? 생각해보니, React에서 태그 안에 간단한 함수를 실행시키는 경우에 onClick = {요기다가!} 바로 즉시 실행 되는 함수를 화살표 함수 형태로 적은 경험이 있는 거 같다. (화살표 함수가 가능한 이유는 표현식이기 때문!이다.)

```
<button onClick={()=>navigate('/')}/>
```

이런식으로 !

이렇게 즉시 실행 함수를 사용하는 이유는 변수를 지역적으로 캡슐화하고 전역 네임스페이스를 오염시키지 않으면서 코드를 실행할 수 있기 때문이다.
그니까 쉽게 말하자면 불필요한 함수 선언을 줄 일 수 있다는 것이다. 코드의 최적화나 가독성을 높이기 위해서는 이러한 즉시 실행 함수를 사용한다고 한다.

보통 재사용성이 높거나 리펙토링이 필요한 함수 같은 경우는 분리하는 것이 좋은데, 그렇지 않은 함수들은 개발할때 계속해서 코드를 분리해서 선언하다보면 굉장히 짧은 함수 조차도 공간을 차지하게 된다는 것을 알 수 있다.

그래서, 간단한 기능의 함수나, 반복적으로 쓰이지 않고 리펙토링이 필요하지 않는 경우에 이 IIFE를 활용하면 좋겠다 라는 생각이 들었다.

IIFE 의 장점 중 하나는 반복 되어 사용되어지는 변수나 함수들을 감지하여 오류 체크를 도와줄 수 있도록 한다. 실제로 lint나 prettier를 사용해서 해당 부분을 해결해 나가고 있는데, 그러한 경우가 없을땐 이렇게 IIFE를 활용해서 하나의 함수로 감싼 후 반복되어지는 부분에 대한 체크를 하면 좋은 도구로 쓰일 수 있겠다 라는 생각이 들었다.

---

다양한 JS 개념에 대해서 알아보았는데, 앞으로도 꾸준히 공부해보겠다 ! 알찬 복습이었다 !
