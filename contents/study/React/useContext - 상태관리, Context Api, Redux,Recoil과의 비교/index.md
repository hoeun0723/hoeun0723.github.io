---
date: '2023-11-02'
title: '[React] useContext - 상태관리 / Context Api / Redux,Recoil과의 비교'
categories: ['공부', 'React']
summary: 'useContext - 상태관리 / Context Api / Redux,Recoil과의 비교 에 대하여 학습하고 정리한 내용입니다.'
thumbnail: './thumbnail.png'
---

**목차**

- 상태관리란? (상태관리 라이브러리)
- 상태관리 툴 종류 (Redux,Recoil,Context Api,useContext)
- useContext (context api와의 비교)
- 상태관리 툴 고르는것에 대한 개인적인 경험과 결론

리액트 hooks를 진행하며 **useContext** 주차 발표를 맡게 되었는데, 이 주차를 설명하기 위해선, **상태관리**에 대해서 먼저 설명하는게 좋지 않을까 라는 생각이 들었다.

# 상태관리

### 프론트에서 상태란?

먼저 상태란, 사물이나 현상이 처해있는 형편이나 모양을 뜻한다.
그럼 우리가 접하는 여러가지 프로그램을 머릿속에 떠올려보며 상태란 무엇인가에 대해 생각해보자.

![](https://velog.velcdn.com/images/hoeun0723/post/9986d100-6dda-4303-8749-33e0ed43a1d0/image.png)
출처 : https://reactjs.org/docs/faq-state.html

- 요약) State은 plain Javascript Object that influences output of render and is managed within the component.
- 상태는 컴포넌트 내부에서 관리되며 어플리케이션의 렌더에 영향을 미치는 플레인 자바스크립트 객체이다.

공식 문서에 나와 있는 상태에 대한 이야기를 살펴보면, **프론트에서의 상태란 "어플리케이션의 화면에 영향을 끼치는 자바스크립트 객체"** 라는 것을 알 수 있다.
간단히 정리하자면, state 즉, **상태는 사용자와의 인터랙션을 통해 동적으로 계속해서 변화하는 데이터를 의미**한다.

예를 들어 내가 인스타 그램에서 누군가의 좋아요를 눌러줬을때 좋아요를 누를 갯수가 1 증가하는 것 모두 상태가 변화하는 것이라고 할 수 있는 것이다.

웹 사이트의 규모가 커지고 복잡해 질수록, 이런 상태들은 점점 많아지고 서로 의존하게 되며 관리가 어려워지곤 한다.

웹사이트를 React로 제작할때 종종 컴포넌트로 나누어 제작하곤 하는데, **만약 서로 다른 컴포넌트에서 동일한 상태를 다루게 된다면 그 출처가 같아야 할 것**이다.

위에서의 예를 들은 인스타그램 좋아요의 경우를 불러오자면

내가 좋아요를 누른 포스트를 보여주는 컴포넌트가 있고, 그 포스트의 좋아요 개수를 나타내는 컴포넌트가 있을 건데, 두가지 컴포넌트 모두 결국 "내가 좋아요 누른 포스트"라는 데이터를 가져와 사용해야 하기 때문이다.

그렇기 때문에 상태의 일관성. 즉, 데이터의 무결성은 중요하게 여겨진다.
만약 서로 다른 여러개의 컴포넌트들이 동일한 상태를 다룬다면, 그 데이터의 정확성을 보장하기 위헤 데이터의 변경을 제한해 데이터의 상태를 항상 같게 유지해야한다. 이런 데이터의 무결성을 위해 **Single source of Truth(신뢰할 수 있는 단일 출처)라는 방법론이 생기기도 했고, React에서도 이 방법론을 택해서 사용하고 있다**.

### 상태의 종류

상태는 크게 범위의 개념에서 **전역상태(Global State)**와 **컴포넌트 간 상태(Cross Component State)**,그리고 **지역상태(Local State)** 세가지로 나눌 수 있다.

**지역 상태**는 특정 컴포넌트 안에서만 관리되는 상태를 뜻한다. 다른 컴포넌트들과 데이터를 공유하지 않는다. 예를 들면, input/selectbox 등 사용자의 입력값을 받는 경우. (보통 Form 데이터들이 지역상태에 속한다고 한다.)

**컴포넌트 간 상태**는 여러가지 컴포넌트에서 관리되는 상태를 나타낸다. 다수의 컴포넌트에서 쓰이고, 또 영향을 미치는 상태를 뜻한다. 프로젝트 곳곳에 쓰이는 모달을 예로 들 수 있는데, 컴포넌트에서 하위 컴포넌트로 props를 넘겨 해당 컴포넌트까지 전달되도록 하는 props drilling 방식을 필요로 한다.

**전역 상태**는 프로젝트 전체에 영향을 끼치는 상태이다. 예를 들면, 유저 기능을 생각하면 된다. 이 또한 props drilling 방식을 활용해서 부모에서 자식으로 데이터를 전달한다.

> props drilling이란, props를 오직 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트를 거치며 컴포넌트에서 다른 컴포넌트로 데이터를 전달하는 과정이다.

### 상태관리는 왜 필요한가?

그래서 상태관리는 말 그대로 위에서 설명한 상태들을 관리하는 것을 의미한다.

서로 다른 두 컴포넌트에 같은 데이터가 필요하다고 할 때, 각 컴포넌트가 부모자식 관계로 되어 있지 않은 이상, 각 컴포넌트 간의 데이터 전달은 어렵다.

데이터를 부모 컴포넌트로 보내고, 다시 그 데이터를 필요한 컴포넌트로 전달 해야한다. 하지만 이렇게 props drilling이 많아지면 이 props가 어디에서 왔는지 확인하기 정말 어려워진다.
그렇기 때문에 각 어플리케이션에 알맞은 상태 관리 툴을 선택 해 상태를 잘 관리하는 것이 중요하다.

[윗 내용 참고자료(훌륭한 블로그 글...)](https://mingule.tistory.com/74)

# 상태관리를 위한 툴

상태관리를 위한 툴에는 다양한게 존재 한다. 하나하나 살펴보도록 하겠다.

### Redux

가장 널리 알려져 있는 React 상태관리 라이브러리 중 하나이다.

**Redux**는 상태 관리를 위한 **JavaScript 라이브러리**로, 주로 React와 함께 사용되며 웹 애플리케이션의 상태를 효율적으로 관리하는 데 도움을 준다. Redux는 **상태 컨테이너 패턴과 단방향 데이터 흐름을 구현하는 데 중점을 두며, 애플리케이션의 상태를 중앙 집중화하여 관리**한다.

Redux의 핵심 개념과 구성 요소는 다음과 같다:

**Store**: Redux는 애플리케이션의 상태를 저장하는 중앙 상태 저장소 또는 스토어를 제공. 스토어는 애플리케이션 상태의 단일 소스로 작동하며, 상태를 읽고 쓰는 데 사용.

**Action**: 액션은 Redux 애플리케이션에서 상태 변경을 일으키는 이벤트 또는 객체. 주로 type 필드를 포함하며, 필요한 경우 추가 데이터를 가질 수 있음.

**Reducer**: 리듀서는 이전 상태와 액션을 받아서 새로운 상태를 반환하는 순수한 함수. 리듀서는 상태 변경 로직을 정의하고 애플리케이션 상태를 업데이트.

**Dispatch**: 디스패치는 액션을 스토어로 보내 상태 변경을 시작하는 역할을 함. 애플리케이션 내에서 액션을 디스패치하면 리듀서가 실행되어 새로운 상태를 생성.

**Subscriber**: 스토어에는 상태 변화를 감지하고 처리하기 위한 구독자 패턴이 내장되어 있음. 이를 통해 상태 변경 시 콜백 함수가 호출되어 UI 업데이트 또는 다른 작업을 수행.

Redux의 장점은 상태 변화를 예측하며 **복잡한 애플리케이션의 데이터 흐름을 이해하기 쉽게 한다는 것**이다. 또한 Redux dev tools와 같은 개발자 도구를 사용하여 **애플리케이션 상태를 디버깅하고 모니터링할 수도 있다**. Redux는 React 외에도 Angular, Vue.js, 백엔드 서버 등 다양한 환경에서 사용할 수 있다.

그러나 Redux를 사용하면 코드 양이 증가할 수 있으며, 간단한 애플리케이션에서는 Redux보다 간단한 상태 관리 도구가 선호될 수 있다.
[더 자세한 설명](https://react-redux.js.org/)

### Recoil

그렇게 Redux를 쓰다가 **더 간단한 상태 관리 도구**가 나온게 바로, **Recoil**이다.

Recoil은 **Facebook에서 개발한 상태 관리 라이브러리**로, React 애플리케이션의 상태를 관리하기 위한 효과적인 도구이다. Recoil은** React의 컴포넌트 기반 아키텍처와 조화롭게 작동**하며, **복잡한 상태 관리 문제를 해결하기 위해 설계**되었다.

Recoil의 주요 특징 및 개념은 다음과 같다:

**Atom state**: 상태를 "atom" 단위로 관리. 애플리케이션 상태를 작은 조각으로 나누고 각각을 개별적으로 업데이트할 수 있게 함. 컴포넌트가 필요한 상태만 구독하고 업데이트할 수 있으므로 성능 최적화에 도움.

**상태 그래프**: 상태 간의 의존성을 그래프로 관리. 상태 간의 관계를 선언적으로 정의하고, 필요한 상태가 변경될 때 자동으로 업데이트되도록 하는 데 도움.

**비동기 데이터 처리**: 비동기 데이터 가져오기 및 업데이트를 간편하게 처리할 수 있음. 비동기 데이터 흐름을 관리하기 위해 Recoil의 selector를 사용할 수 있음.

**개발자 도구 지원**: 개발자 도구를 포함하여 디버깅 및 성능 모니터링을 위한 도구를 제공.

Recoil은 상태 관리를 단순화하고 유연하게 다룰 수 있는 강력한 도구로서, 복잡한 애플리케이션의 상태를 효율적으로 관리할 때 유용하다. React 컴포넌트와 함께 사용할 수 있으며, 특히 **대규모 및 고성능 웹 애플리케이션을 개발하는 데 적합**하다.
Recoil은 Redux와 같은 다른 상태 관리 라이브러리와 비교하여 보다 간편한 상태 관리 솔루션을 제공하고 있으며, React 애플리케이션 개발자들에게 선택 사항으로 제공한다.
[더 자세한 설명](https://recoiljs.org/ko/docs/introduction/core-concepts/)

### Context Api

Context Api는 redux와 recoil과는 다르게 외부 라이브러리가 아닌, React내부에 존재하는 라이브러리 중 하나이다. 즉, React 프레임워크의 일부라고 볼 수 있다.

Context Api는 **React 컴포넌트 트리를 통해 데이터를 전달하고 공유하기 위한 방법을 제공하는 API**이다. 이를 통해 컴포넌트 간에 데이터를 손쉽게 공유하고 데이터의 전역적인 상태를 관리할 수 있습니다.

Context API의 주요 개념과 구성 요소는 다음과 같다:

**Provider**: 데이터를 제공하는 컴포넌트. 데이터를 제공하려는 컴포넌트의 상위 컴포넌트에서 Provider를 사용하여 데이터를 설정하고 컴포넌트 트리에 노출.

**Consumer**: 데이터를 소비하는 컴포넌트. Consumer 컴포넌트를 사용하여 제공된 데이터를 사용하고 해당 데이터에 액세스할 수 있음.

**Context 객체**: createContext 함수를 사용하여 Context 객체를 생성할 수 있으며, 이 객체는 데이터를 저장하고 제공하는 역할을 함. Provider에서 제공하고 Consumer에서 사용.

Context Api를 사용하면 데이터의 전역적인 상태를 관리할 수 있으며, 컴포넌트 간에 데이터를 손쉽게 전달할 수 있다. 이는 특히 **컴포넌트 트리의 중간에 있는 컴포넌트에서 데이터를 필요로 하는 하위 컴포넌트로 데이터를 전달하는 데 유용**하다.

예를 들어, 사용자 인증 정보, 애플리케이션 테마, 언어 설정 등과 같이 애플리케이션 전반에서 공통적으로 사용되는 데이터를 Context Api를 사용하여 관리할 수 있다.
이것은 **Redux나 MobX와 같은 상태 관리 라이브러리를 사용하지 않고도 상태 관리를 할 수 있는 간단한 방법 중 하나**이다.

**Redux와 Recoil의 기본적인 아이디어 및 구조가 React의 Context Api에 영감을 받았다고 한다.**
Context Api를 사용하면 데이터를 상위 컴포넌트에서 하위 컴포넌트로 전달할 수 있으며, 컴포넌트 간의 데이터 공유를 쉽게 구현할 수 있는데, Redux와 Recoil은 이러한 아이디어를 확장하고 발전시켜서 상태 관리를 효과적으로 다루는 라이브러리로 만들어졌다고한다. 위와 같은 라이브러리들은 React 컴포넌트 트리에서 데이터의 중앙 집중화된 관리와 전역 상태 관리를 지원하며, Context Api를 기반으로 구현된다.

[Context Api-리액트 공식문서](https://ko.legacy.reactjs.org/docs/context.html)

# useContext

그렇다면, 드디어 오늘의 본론 useContext란 무엇일까?
[공식문서](https://react.dev/reference/react/useContext)

useContext란, React의 훅 중 하나로 React 애플리케이션 내에서 Context Api에서 제공된 데이터를 손쉽게 읽어올 수 있도록 도와주는 hook을 의미한다.

useContext를 사용하려면 먼저 Context Api를 설정하고 데이터를 제공하는 Context Provider 컴포넌트를 생성해야 한다. 그런 다음 useContext 훅을 사용하여 해당 Context 객체로부터 데이터를 가져올 수 있다.

간단한 예를 들어보자면,

먼저, Context를 생성하고 데이터를 제공하는 Provider를 설정한다:

```
// Context 생성
const MyContext = React.createContext();

// 데이터를 제공하는 Provider
function MyProvider({ children }) {
  const sharedData = "This is shared data";

  return <MyContext.Provider value={sharedData}>{children}</MyContext.Provider>;
}
```

이제 useContext를 사용해서 데이터를 읽어올 수 있다.

```
function MyComponent() {
  const data = React.useContext(MyContext);

  return <div>{data}</div>;
}

function App() {
  return (
    <MyProvider>
      <MyComponent />
    </MyProvider>
  );
}
```

MyComponent에서 useContext 훅을 사용하여 MyContext에서 제공된 데이터를 가져오고, App 컴포넌트에서 MyProvider로 데이터를 제공한다.
결과적으로 MyComponent에서는 "This is shared data"가 화면에 표시될 것이다.

useContext를 사용하면 컴포넌트 내에서 데이터에 쉽게 액세스할 수 있으며, 전역 데이터 상태를 구현하는 데 유용하다. 이는 사용자 인증 정보, 테마 설정, 언어 설정, 애플리케이션 설정 등과 같이 여러 컴포넌트에서 공유해야 하는 데이터를 다룰 때 유용하다.

### Context Api와의 공통점과 차이점

**공통점**

**데이터 공유**: useContext와 Context Api는 컴포넌트 간에 데이터를 전달하고 공유하기 위한 도구이다.
**전역 데이터**: 둘 다 전역 데이터 상태를 구현할 수 있으며, 컴포넌트 트리 어디에서나 사용할 수 있다.

**차이점**

**API 유연성**: useContext는 특정 Context 객체를 구독하고 해당 데이터를 읽기 위한 간단한 hook이다. 반면에 Context Api는 Consumer와 Provider를 사용하여 데이터를 공유하고 업데이트하는 데 더 많은 구조와 유연성이 필요하다.

**문법**: useContext는 간단한 hook으로, 데이터를 읽기 위해 컴포넌트 내에서 사용된다. Context Api는 Provider를 사용하여 데이터를 제공하고 Consumer를 사용하여 데이터를 소비하는 방식을 취한다.

**코드 간결성**: useContext를 사용하면 더 간결한 코드를 작성할 수 있으며, 컴포넌트가 더 깔끔하게 구성된다. Context Api는 명시적으로 Consumer를 사용해야 하므로 코드가 더 복잡해질 수 있다.

**렌더링 성능 최적화**: useContext를 사용하면 컴포넌트가 자동으로 업데이트되지 않는 한 컴포넌트가 데이터를 구독하지 않는다. Context Api를 사용할 때는 컴포넌트가 데이터가 변경될 때마다 렌더링될 수 있다. useContext를 사용하면 React가 컴포넌트의 의존성을 자동으로 추적하여 최적화한다.

요약하면, useContext는 Context Api를 사용한 데이터 공유를 단순화하고 더 간단한 코드로 구현할 수 있도록 도와주는 React의 hook이다. Context Api는 더 복잡한 구조와 유연성을 제공하며, 데이터 공유를 조금 더 세밀하게 제어하려는 경우에 유용할 수 있다.

### 그렇다면 우리는?

Context Api의 사용을 더욱 더 단순화 시켜준 React의 hook 인 useContext를 사용하는게 좋을 것이다!!

# 프로젝트 경험담

지금까지 큰 프로젝트만 총 3가지를 해왔는데, Redux,Recoil,context Api(useContext) 3가지의 상태관리를 모두 사용해봤다.

내가 생각하는 각각의 장단점과 어떨때 사용하면 좋을 지에 대한 부분을 나의 소신발언..같은 느낌으로 남겨보겠다.

**Redux**
일단, Redux는 정말 오래전부터 사용해오던 상태관리 라이브러리이다. 그래서 인지 정말 다양한 회사들이 아직까지도 Redux를 사용해 오고 있고 그 때문에 관련 레퍼런스도 굉장히 많다.
하지만, 현재는 Redux보다 더 좋은 상태관리 라이브러리들이 나오고 있는 추세라 조금씩 사용을 줄이고 있는 추세인거 같기도 하다.
나는 Redux를 상태관리를 할때 그래도 한번은 경험해 보면 좋겠다고 생각한다. 지금 취준생들은 회사에 입사하고 나면 아직까지 Redux를 활용하는 회사들도 꽤 있을 것이다. (사용되고 있던 기술들을 한번에 바꾸는 일은 쉽지 않음. 시간이 필요.)
많이 사용해 왔던 기술이기도 하고, 추후 근무 시 필요한 지식이라고 생각하여 공부해 두는게 좋을 거 같다.
음.. 하지만, 솔직히 말해서 상태관리 공부가 주가 아닌, 프로젝트 진행이 주라면, 좀 더 간편한 다른 라이브러리를 활용하는 게 좋을 거 같다.

**Recoil**
Recoil은 음.. 아마 유명한 회사를 말해보자면 toss가 Recoil을 쓰고 나서 점점 떠오른게 아닌가 생각한다. 내가 Recoil을 처음 공부할 땐, "Recoil 그거 새로운 기술인데 괜찮은거 맞아요? 웅성웅성 그래도 토스가 요즘 밀고 있대요~!" 막 이런 말이 들렸던 거 같다 ㅋㅋㅋㅋ 그래서 Redux로 꾸준히 공부하냐 vs 최신 기술 Recoil을 써보냐 파가 나뉘어 졌던 거 같기도 하다.
솔직히 나는 프론트 공부하는 입장에서 새로운 기술을 계속 접목 하는 것이 더 올바른 마인드 라고 생각한다. 특히나 '프론트' 분야에서. 계속 해서 새로운 기술이 나오고 그 기술로 트랜드가 변경되는게 우리 분야라고 생각하기 때문에, 적극적으로 공부하고 받아들이는 게 좋은 선택이 아닐까 한다.
갑자기 다른 길로 빠졌는데, Recoil은 정말.. 처음 접했을때 Redux와 비교 해서 그런지 정말정말 편하다는 생각을 많이 했다. 사용 법이 너무 간단하고, useState 사용하는 것과 구조가 비슷하여 습득이 빨랐던 거 같다.
음.. 보통 프로젝트 시 상태관리 할 때 내가 제일 추천하는 라이브러리는 사용하기 간편한 Recoil이다.
(하지만 바로 위에서 말했듯이 프론트의 기술 트랜드는 빠른 속도로 변화한다. 그니까, 지금 이 발언이 나중에 가선 똥발언이 될 수도 있다는 것이다... 그저 2023년 나의 소신발언이라고 생각해주세요..)

**Context Api / useContext**
물론 모든 상태관리 라이브러리들이 Context Api로 되어 있는건 아니지만, 내가 프로젝트를 진행 할 당시, styled-component도 활용하고 있었는데, 이 또한 context Api로 만들어져 있다고 알고 있다.(그 외에도, recoil, redux 등..)

Redux와 Recoil은 전역 상태관리 라이브러리 이기 때문에, 프로젝트 내부에 전역 상태가 많으면 Redux나 Recoil을 사용하는 것이 좋지만,
만약 전역 상태가 거의 없다면 다른 상태관리 툴을 이용하는 것이 좋다.
(전역적으로 관리 해야하는 상태보다는 서버에서 데이터를 요청해, 로컬 상태관리가 아닌 서버 상태와 동기화 해야하는 일이 많을 경우. 다른 상태관리 툴 추천!)
그래서 선택한 것이 바로, Context Api였는데,
Context Api는 계층적인 컴포넌트 구조에서 상태에 따른 렌더링을 이해하기 좋다고 생각한다.
나는 프로젝트를 할때 Context Api의 Provider는 props drilling을 해결하는 역할만 하고 직접적인 상태관리는 custom hooks를 통해 관리 했다.

[그때 당시 작성 했던, 상태관리에 대한 고민 + 프로젝트 내부 반영에 대한
Github Wiki 링크](<https://github.com/yulpumta-clone-team/Co-nect/wiki/%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC-migration-(redux-%E2%86%92-react-context-api)>)

Context Api나 useContext는 다른 라이브러리들의 기본이기 때문에, 나는 처음 상태관리를 통한 프로젝트를 진행 할때 (시간 제한이 있는 프로젝트가 아닌, 공부를 위한 개인 프로젝트 진행 시) 이 상태관리 툴을 추천한다.
어떻게 상태들을 관리 할 수 있는지 이해가 되고, 이를 처음으로 써보면 다른 상태관리 툴들도 익숙하게 쓸 수 있을 것 이기 때문이다.
또한, 전역적인 상태관리가 많이 필요하지 않을 때에도 이 상태관리 툴을 추천하기도 한다.

# 결론

useContext의 사용방법에 대해서 많이 다루진 못했지만, 내가 그동안 고민하고 공부해 왔던 상태관리 툴에 관한 내용들을 많이 작성해 본 거 같다.
지금의 내 글이 누군가에겐 도움이 많이 되길 바라며, 나도 앞으로 상태관리에 대해 더 많이 공부하고 새로운 기술도 더 많이 사용해보며 성장해야겠다고 생각했다 !!!
앞으로 더 다양한 상태관리 라이브러리들도 다뤄보고 싶다!

전반적인 useContext 사용법은 실습으로 다루겠습니다 🔥
