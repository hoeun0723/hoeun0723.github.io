---
date: '2024-08-13'
title: '[CSS] px과 em(62.5%) / css 적용 우선순위(tailwind 경험) / 우리가 css in js와 헤어지는 이유+css 라이브러리'
categories: ['공부', 'css']
summary: 'px과 em(62.5%) / css 적용 우선순위(tailwind 경험) / 우리가 css in js와 헤어지는 이유+css 라이브러리 에 대하여 학습하고 정리한 내용입니다.'
thumbnail: './thumbnail.png'
---

# px과 em(rem)

평소 css 코드를 작성할때 특정한 상황이 아니면 px 단위 사용을 지양했는데, 뭔가 조금 더 명확한 이유를 가지고 해당 부분을 지속해야하지 않나 라는 생각이 강하게 들었다.

> **px이란?**
> 절대 단위: px은 고정된 단위로, 1픽셀은 화면상의 하나의 점을 의미합니다. 이는 디스플레이 장치의 해상도에 따라 다를 수 있지만, 일반적으로 고정된 크기를 의미합니다.
> **em이란?**
> 상대 단위: em은 부모 요소의 폰트 크기를 기준으로 한 상대적 크기 단위입니다. 예를 들어, 부모 요소의 폰트 크기가 16px이라면 1em은 16px을 의미합니다.

설명과 같이 16px이 1em을 의미하고 **px은 절대단위**이기에 보통 **radius 값이나, border 값 등 고정된 값으로 보여져야하는 부분**에 사용해왔다.
**em은 상대단위**이기에 부모 요소의 폰트 크기를 기준으로 하는데, **유연한 레이아웃이나 반응형 디자인을 하는 경우**에는 em(rem)을 사용해왔다.
(나는 주로 rem 사용을 더 많이 해왔는데, 둘의 차이점은 rem은 루트 단위를 기준으로 상대적인 값이라는 점이다.)

왜 16px이 1em인지 궁금해 할 수도 있는데, 보통 < html />의 기본 폰트 크기는 16px로 설정되어 있기 때문이다.

### px과 em의 사용 경우

px의 사용 경우:

1. 정확한 크기를 원할 때: 버튼, 아이콘, 이미지 등의 크기를 정확하게 지정하고 싶을 때 사용합.
2. 레이아웃이 고정되어야 할 때: 레이아웃 요소가 고정된 크기를 가져야 하거나, 특정 픽셀 단위로 디자인된 경우에 사용.
3. 디자인이 여러 디바이스에서 동일하게 보이길 원할 때: 특정 요소가 모든 디바이스에서 동일한 크기로 보이도록 하려면 px 단위를 사용.

em의 사용 경우 :

1. 유연한 레이아웃: em은 부모 요소의 폰트 크기를 기준으로 하므로, 컨테이너나 텍스트가 유연하게 변하는 레이아웃에서 유용.
2. 폰트 크기 설정: 웹 페이지에서 폰트 크기를 설정할 때 em을 사용하면, 폰트 크기가 부모 요소의 크기에 따라 유동적으로 조정할 수 있다.
3. 반응형 디자인: 다양한 화면 크기에 대응하는 반응형 디자인에서, em 단위를 사용하여 텍스트나 레이아웃 요소가 유연하게 크기를 조정할 수 있다.

## 내가 figma에서 px 단위를 rem으로 바꿀땐 /10을 해줬던 거 같은데..? 왤까?

내가 평소 작업하던 프로젝트의 UI/UX를 보기위해서 사용하는 figma는 단위를 px로 표현해줄때가 많아서 rem으로 단위를 바꿔가며 사용하는 경우가 많았는데, 그때 마다 아무런 생각없이 10을 나눠가며 해줬던 기억이 난다.

이에 대한 이유는 바로 globalstyle에 직접해준 **font-size : 62.5%**에 담겨있는데,
보통 rem을 루트 단위를 기준으로 상대적인 크기를 가지는 단위이기에 루트 style 초기세팅에 62.5%를 적어준 것이다.
매번, figma에서 px 단위를 16으로 나눠가며 계산해서 rem을 작성하게 되면 번거로움이 있기에,
1rem = 16px 즉, 10px = 0.625rem! 그니까 62.5%를 초기 폰트 사이즈에 설정을 해주게 되면 figma에서 폰트를 가지고 올때에도 rem으로 변동할때 간편하게 10으로만 나누면 되는 것이었다.

이렇게 간편한 방식에 대한 초기세팅을 했기에 개발을 진행하는것이 편리했고 초기세팅의 중요성에 대해서 다시 한번 더 깨달았다.

# CSS 적용 우선순위

css 적용 우선순위는 보통

1. 기본적으로 뒤에 나오는 css가 우선순위가 높다.
2. !important > inline style attribute > id > class, 다른 attribute, 수도클래스(:first-child같은 것) > tag element, 수도엘레먼트(::before같은 것) 순으로 우선순위가 높다.
3. 우선순위가 같다면 개수가 많은 css가 우선순위가 높다.

이렇게 구성 되어진다!

이런 우선순위로 인하여 불편함을 느꼈던 경우는 바로 globalstyle 파일에서 였다.
보통 css 라이브러리를 사용하곤 했기에 직접적인 우선순위를 따져가며 작성한 css 파일은 globalstyle이 유일했기에 우선순위 때문에 적용하는데 신경 썼던 기억이 난다.

css 파일 외에도 styled-component 내부에서 수도 클래스나 수도엘레먼트를 신경쓰며 부모 컴포넌트에서 상속되어지는 다른 자식 컴포넌트들의 스타일 코드를 우선순위를 매기며 진행했던 기억이 났다.

### tailwind 를 사용하며 우선순위때문에 불편했던 점 + 해결한 점

css에서의 우선순위 외에도 tailwind를 적용하며 우선순위 때문에 겪은 불편함이 있었고, 해결한 경험이 있는데

taliwind는 유틸리티 클래스를 사용하다보니 overide 및 적용 우선순위를 파악하기 어렵다는 단점이 있는데, 예를 들어 className에 작성한 스타일 코드 외에도 다른 곳에도 스타일 코드를 작성하게 되면 css 케스케이딩 때문에 적절한 동작을 할 수 없는 경우가 생기곤 한다.

[실제로 카카오 에서도 이러한 케스케이딩 때문에 twin.macro라는 것을 도입했고,](https://fe-developers.kakaoent.com/2022/220303-tailwind-tips/)

나는 tw-merge를 도입하여 해당 문제를 해결하였다.
사용한 패키지는 https://github.com/dcastil/tailwind-merge 이고, 해당 패키지에서 제공하는 함수를 바로 사용하는 것은 종속성이 높아질것이라고 생각하여 유틸리티 함수로 따로 관리하였다.

# 우리가 css in js와 헤어지는 이유 + 다양한 css 라이브러리

css in js의 대표적인 예시 중 styled-component가 있는데,
평소 개발을 할때 styled-component를 애용하며 사용해왔었기에 styled-component의 장단점이 너무나 확실하게 느껴졌다..

styled-component는 React 기반의 프로젝트에서 많이 사용된다. 특히 대기업의 프론트엔드 팀이나 스타트업들이 많이 채택하고 있으며, 카카오, 네이버 등에서도 사용 사례가 있다.
컴포넌트 기반의 스타일링, 스타일과 로직의 결합, 테마 지원과 유지 보수의 편리성 적인 면에서 다양한 이점을 주곤 한다.

내가 느꼈던 가장 큰 이점은 바로 유지 보수가 간편하고 재사용성이 높아진다라는 것이었다. 또한 분류가 잘 되어서 가독성도 굉장히 좋았다.

하지만,

1. 런타임 오버헤드와 크기 증가로 인한 성능 문제
2. ssr이나 코드 스플리팅을 사용하는 경우 빌드 설정이 복잡해진다.
   등등의 문제가 있고 실제로 내가 구현한 프로젝트에서도 크기 증가로 인한 성능 문제가 발생했다고 생각한다.
   하지만 나는 Next.js가 아닌 React였고 적절한 라이브러리를 선택했다고 생각했으며, 해당 라이브러리를 도입하기 전에 장단점을 모두 비교하며 고민해보았는데, 해당 부분에 대해서 정리해 보겠다.

## 상황에 맞는 css 라이브러리

css 개발을 진행할때 함께할 라이브러리를 선택하곤 하는데 내 개발 스택에 걸맞는 라이브러리를 이유를 가지고 선택하는것이 중요하다.

나는 React를 사용하고 있었기에 styled-component를 선택했는데 만약 Next.js 즉 ssr 을 사용했다면 styled-component가 오히려 안 좋은 영향력을 줬을 것이라고 생각한다.

다양한 라이브러리를 알아보며 몇가지 눈에 들어온 것들을 소개해보자면

**1. SCSS**
SCSS(Sassy CSS)는 Sass(Syntactically Awesome Style Sheets)의 문법 중 하나로, CSS의 확장판이다. 기존 CSS에 비해 더 많은 기능을 제공하여 코드의 유지보수성과 재사용성을 높일 수 있다. SCSS는 CSS와 완전히 호환되며, 기존 CSS 코드를 쉽게 통합할 수 있다.
<주요 특징>
변수: 색상, 폰트 크기 등을 변수로 정의해 재사용 가능.
중첩(Nesting): CSS 선택자들을 중첩해 구조적으로 작성 가능.
믹스인(Mixins): 재사용 가능한 스타일 블록을 정의하여 코드 중복을 줄임.
상속(Inheritance): 공통 스타일을 다른 선택자에 쉽게 적용.
파셜(Partials)과 임포트(Import): 파일을 분리해 관리할 수 있어 코드의 모듈화가 가능.
<사용 사례>
SCSS는 복잡한 스타일링이 요구되는 웹사이트나 애플리케이션에서 사용된다. 많은 프론트엔드 개발자들이 SCSS를 이용해 효율적인 스타일링 작업을 수행하며, 특히 대규모 프로젝트에서 유용하다.

**2. Emotion**
Emotion은 CSS-in-JS 라이브러리로, 자바스크립트 코드 내에서 스타일을 작성하고 관리할 수 있게 해준다. 특히 React와 잘 통합되어 있으며, 빠르고 유연한 스타일링 솔루션을 제공한다. 다양한 방식으로 스타일을 작성할 수 있어, 개발자의 스타일링 작업을 돕는다.
<주요 특징>
CSS-in-JS: 자바스크립트 내에서 스타일을 작성해, 컴포넌트와 스타일을 함께 관리.
유연한 스타일링: 클래스 기반, 스타일 객체, 템플릿 리터럴 등 다양한 스타일링 방식 제공.
퍼포먼스 최적화: 작은 크기와 빠른 런타임 성능.
테마 지원: 테마 기능을 통해 일관된 스타일 관리 가능.
서버사이드 렌더링(SSR): 서버사이드 렌더링을 쉽게 지원하여 SEO 친화적.
<사용 사례>
Emotion은 React 기반의 프로젝트에서 자주 사용된다. 특히 동적 스타일링이 필요하거나, 스타일과 로직을 한 곳에서 관리하고자 할 때 유용하다. 스타일링과 성능 최적화가 중요한 대규모 애플리케이션에서 강점을 발휘한다.

**3. Panda.css**
Panda.css는 유틸리티 중심의 CSS 프레임워크로, 경량화된 Tailwind CSS와 유사한 접근 방식을 취합니다. 미리 정의된 유틸리티 클래스를 통해 빠르게 스타일을 적용할 수 있으며, 성능에 민감한 프로젝트에서 효과적이다.
<주요 특징>
유틸리티 클래스: 특정 스타일 속성을 나타내는 클래스를 사용해 빠르게 스타일 적용.
경량화: 불필요한 코드 없이 필요한 기능만 포함, 파일 크기 최소화.
모듈화: 필요한 모듈만 선택적으로 사용 가능, 프로젝트에 맞게 커스터마이징 용이.
반응형 디자인: 다양한 디바이스에서 일관된 UI를 제공하는 반응형 유틸리티 지원.
<사용 사례>
Panda.css는 빠른 프로토타이핑이 필요한 프로젝트나 성능 최적화가 중요한 프로젝트에서 유용하다. 스타일링이 간결하고 예측 가능한 유틸리티 클래스 기반이므로, 스타일 일관성을 유지하면서도 경량의 애플리케이션을 구축하는 데 적합하다. 특히, 스타트업이나 소규모 프로젝트에서 빠른 개발을 지원한다.

이렇게 3가지의 라이브러리를 살펴보며 csr ssr 그리고 그 외에 단점과 장점이 명확하기에 상황에 걸맞는 라이브러리 선택이 중요하다고 느꼈고 앞으로 나의 선택에 있어서도 큰 도움이 될 것같다고 생각했다.
